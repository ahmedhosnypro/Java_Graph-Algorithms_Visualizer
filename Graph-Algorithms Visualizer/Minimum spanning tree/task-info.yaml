type: edu
files:
- name: src/visualizer/ApplicationRunner.java
  visible: true
  text: |
    package visualizer;

    public class ApplicationRunner {
        public static void main(String[] args) {
            new MainFrame();
        }
    }
  learner_created: false
- name: src/visualizer/MainFrame.java
  visible: true
  text: |-
    package visualizer;

    import javax.swing.*;

    public class MainFrame extends JFrame {
        public MainFrame() {
            setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            setSize(300, 300);
            setVisible(true);
            setLayout(null);
        }
    }
  learner_created: false
- name: src/visualizer/UndirectedGraph.java
  visible: true
  text: |-
    package visualizer;

    import javax.swing.*;
    import java.awt.*;
    import java.awt.event.MouseAdapter;
    import java.awt.event.MouseEvent;
    import java.util.HashSet;
    import java.util.Set;

    public class UndirectedGraph extends JPanel {
        private final Set<Vertex> vertices = new HashSet<>();
        private final Set<UndirectedEdge> edges = new HashSet<>();

        private final Set<JLabel> weightLabels = new HashSet<>();

        final MainFrame mainFrame;

        public UndirectedGraph(MainFrame mainFrame, LayoutManager layout, String name) {
            this.mainFrame = mainFrame;
            setLayout(layout);
            setName(name);
            setForeground(Color.RED);
            setBackground(Color.BLACK);
            setBounds(0, 0, 800, 600);

            addMouseListener(new MouseAdapter() {
                @Override
                public void mouseClicked(MouseEvent e) {
                    super.mouseClicked(e);
                    switch (mainFrame.getMode()) {
                        case ADD_VERTEX -> createVertex(e);
                        case ADD_EDGE -> {
                            // To Do
                        }
                        case NONE_MODE -> whiteVertices();
                    }
                }
            });
        }

        protected void paintChildren(Graphics g) {

            Graphics2D g2 = (Graphics2D) g;
            g2.setStroke(new BasicStroke(3));
            g2.setColor(Color.WHITE);
            for (var edge : edges) {
                drawEdge(g2, edge);
            }

            super.paintChildren(g);
        }

        private void setupLabelPosition(UndirectedEdge edge) {
            var nodes = edge.getNodes();
            int x1 = nodes[0].getCenterX();
            int y1 = nodes[0].getCenterY();
            int x2 = nodes[1].getCenterX();
            int y2 = nodes[1].getCenterY();

            int centerX = Math.min(x1, x2) + Math.abs(x1 - x2) / 2;
            int centerY = Math.min(y1, y2) + Math.abs(y1 - y2) / 2;

            int dist = 25;
            int distSqr = dist * dist;
            if (x1 - x2 != 0) {
                float slope = (float) (y1 - y2) / (x2 - x1);
                double slopeSqr = slope * slope;
                double diffX = Math.sqrt(distSqr / (1 + slopeSqr));
                double diffY = Math.sqrt(distSqr - distSqr / (1 + slopeSqr));

                centerX = (int) (centerX + diffX);
                centerY = (int) (centerY + diffY);
            }
            edge.getWeightLabel().setBounds(centerX, centerY, 30, 30);
        }

        private void createVertex(MouseEvent e) {
            whiteVertices();
            Vertex vertex = VertexCreator.createVertex(mainFrame, e.getX(), e.getY());
            if (vertex != null) {
                add(vertex);
                vertices.add(vertex);
                paintComponents(getGraphics());
                mainFrame.repaint();
            }
        }

        void whiteVertices() {
            vertices.forEach(Vertex::resetColor);
            mainFrame.repaint();
        }

        private void drawEdge(Graphics2D g2, UndirectedEdge edge) {
            var nodes = edge.getNodes();
            int x1 = nodes[0].getCenterX();
            int y1 = nodes[0].getCenterY();
            int x2 = nodes[1].getCenterX();
            int y2 = nodes[1].getCenterY();

            g2.drawLine(x1, y1, x2, y2);
        }

        void addNewEdge(UndirectedEdge newEdge, UndirectedEdge stupidStageLogic) {
            if (!isDuplicateEdge(newEdge)) {
                edges.add(newEdge);
                add(newEdge);


                int x1 = newEdge.getNodes()[0].getCenterX();
                int y1 = newEdge.getNodes()[0].getCenterY();
                int x2 = newEdge.getNodes()[1].getCenterX();
                int y2 = newEdge.getNodes()[1].getCenterY();
                int centerX = Math.min(x1, x2) + Math.abs(x1 - x2) / 2;
                int centerY = Math.min(y1, y2) + Math.abs(y1 - y2) / 2;
                newEdge.setBounds(centerX-3, centerY-3, 6, 6);
                stupidStageLogic.setBounds(centerX, centerY, 6, 6);

                edges.add(stupidStageLogic);
                add(stupidStageLogic);

                setupLabelPosition(newEdge);
                weightLabels.add(newEdge.getWeightLabel());
                add(newEdge.getWeightLabel());

                whiteVertices();

                mainFrame.repaint();
            }
        }

        void removeEdge(UndirectedEdge edge) {
            remove(edge);
            edges.remove(edge);
            remove(edge.getWeightLabel());
            var oppositeEdge = edges
                    .stream()
                    .filter(it -> it.getNodes()[0] == edge.getNodes()[1] && it.getNodes()[1] == edge.getNodes()[0])
                    .findFirst();
            oppositeEdge.ifPresent(e -> remove(e.getWeightLabel()));
            oppositeEdge.ifPresent(this::remove);
            getWeightLabels().remove(edge.getWeightLabel());
            edge.getNodes()[0].disconnectVertex(edge.getNodes()[1]);
            edge.getNodes()[1].disconnectVertex(edge.getNodes()[0]);

            mainFrame.repaint();
        }

        void removeVertex(Vertex vertex) {
            remove(vertex);
            vertices.remove(vertex);
            edges.stream().filter(e -> e.getNodes()[0] == vertex || e.getNodes()[1] == vertex).forEach(this::removeEdge);
            edges.removeIf(e -> e.getNodes()[0] == vertex || e.getNodes()[1] == vertex);
            mainFrame.repaint();
        }

        void reset() {
            for (var vertex : vertices) {
                remove(vertex);
            }
            vertices.clear();

            for (var edge : edges) {
                remove(edge);
            }
            edges.clear();

            for (var label : weightLabels) {
                remove(label);
            }
            weightLabels.clear();

            mainFrame.setMode(Mode.ADD_VERTEX);

            mainFrame.repaint();
        }


        private boolean isDuplicateEdge(UndirectedEdge newEdge) {
            return edges.stream()
                    .anyMatch(e -> e.getNodes()[0] == newEdge.getNodes()[0] && e.getNodes()[1] == newEdge.getNodes()[1]);
        }

        // getters
        Set<UndirectedEdge> getEdges() {
            return edges;
        }

        public Set<JLabel> getWeightLabels() {
            return weightLabels;
        }

        public Set<Vertex> getVertices() {
            return vertices;
        }
    }
  learner_created: true
- name: src/visualizer/DefaultMenuBar.java
  visible: true
  text: |
    package visualizer;

    import javax.swing.*;
    import java.awt.event.KeyEvent;

    public class DefaultMenuBar extends JMenuBar {
        private final MainFrame mainFrame;
        private final JMenu fileMenu = new JMenu("File");
        private final JMenu modeMenu = new JMenu("Mode");
        private final JMenu algorithmsMenu = new JMenu("Algorithms");
        private final JMenuItem addVertex = new JMenuItem(Mode.ADD_VERTEX.getName());
        private final JMenuItem addEdge = new JMenuItem(Mode.ADD_EDGE.getName());
        private final JMenuItem removeVertex = new JMenuItem(Mode.REMOVE_VERTEX.getName());
        private final JMenuItem removeEdge = new JMenuItem(Mode.REMOVE_EDGE.getName());
        private final JMenuItem newMenuItem = new JMenuItem("New");
        private final JMenuItem noneModeMenuItem = new JMenuItem(Mode.NONE_MODE.getName());
        private final JMenuItem DFS_menuItem = new JMenuItem("Depth-First Search");
        private final JMenuItem BFS_menuItem = new JMenuItem("Breadth-First Search");
        private final JMenuItem dijkstraAlgorithmMenuItem = new JMenuItem("Dijkstra's Algorithm");
        private final JMenuItem exit = new JMenuItem("Exit");

        DefaultMenuBar(MainFrame mainFrame) {
            mainFrame.setJMenuBar(this);
            this.mainFrame = mainFrame;
            initComponents();
        }

        void initComponents() {
            fileMenu.setName("File");
            add(fileMenu);

            newMenuItem.setName("New");
            newMenuItem.addActionListener(e -> mainFrame.getGraph().reset());

            exit.setName("Exit");
            exit.addActionListener(e -> System.exit(0));

            fileMenu.add(newMenuItem);
            fileMenu.addSeparator();
            fileMenu.add(exit);

            modeMenu.setName("Mode");
            modeMenu.setMnemonic(KeyEvent.VK_Q);
            add(modeMenu);


            addVertex.setName("Add a Vertex");
            addEdge.setName("Add an Edge");
            removeVertex.setName("Remove a Vertex");
            removeEdge.setName("Remove an Edge");
            noneModeMenuItem.setName("None");

            addVertex.addActionListener(e -> mainFrame.setMode(Mode.ADD_VERTEX));
            addEdge.addActionListener(e -> mainFrame.setMode(Mode.ADD_EDGE));
            removeVertex.addActionListener(e -> mainFrame.setMode(Mode.REMOVE_VERTEX));
            removeEdge.addActionListener(e -> mainFrame.setMode(Mode.REMOVE_EDGE));
            noneModeMenuItem.addActionListener(e -> mainFrame.setMode(Mode.NONE_MODE));

            modeMenu.add(addVertex);
            modeMenu.add(addEdge);
            modeMenu.add(removeVertex);
            modeMenu.add(removeEdge);
            modeMenu.add(noneModeMenuItem);

            algorithmsMenu.setName("Algorithms");
            DFS_menuItem.setName("Depth-First Search");
            BFS_menuItem.setName("Breadth-First Search");
            dijkstraAlgorithmMenuItem.setName("Dijkstra's Algorithm");

            DFS_menuItem.addActionListener(e -> mainFrame.setMode(Mode.DFS_ALGORITHM));
            BFS_menuItem.addActionListener(e -> mainFrame.setMode(Mode.BFS_ALGORITHM));
            dijkstraAlgorithmMenuItem.addActionListener(e -> mainFrame.setMode(Mode.DIJKSTRA_ALGORITHM));

            algorithmsMenu.add(DFS_menuItem);
            algorithmsMenu.add(BFS_menuItem);
            algorithmsMenu.add(dijkstraAlgorithmMenuItem);

            add(algorithmsMenu);
        }
    }
  learner_created: true
- name: src/visualizer/UndirectedEdge.java
  visible: true
  text: |
    package visualizer;

    import javax.swing.*;
    import java.awt.*;
    import java.awt.event.MouseAdapter;
    import java.awt.event.MouseEvent;

    public class UndirectedEdge extends JComponent {
        private Vertex[] nodes = new Vertex[2];
        private int weight;
        private JLabel weightLabel = new JLabel();
        private final UndirectedGraph graph;

        public UndirectedEdge(Vertex fstNode, Vertex sndNode, int weight, UndirectedGraph graph) {
            this.graph = graph;
            nodes[0] = fstNode;
            nodes[1] = sndNode;
            this.weight = weight;

            fstNode.connectVertex(sndNode, weight);

            setName(String.format("Edge <%c -> %c>", fstNode.getId(), sndNode.getId()));

            weightLabel.setFont(new Font("Arial", Font.BOLD, 20));
            weightLabel.setForeground(Color.RED);
            weightLabel.setText(String.valueOf(weight));
            weightLabel.setName(String.format("EdgeLabel <%c -> %c>", fstNode.getId(), sndNode.getId()));

            setBackground(Color.WHITE);
            addEventListeners();
        }

        void addEventListeners() {
            addMouseListener(new MouseAdapter() {
                @Override
                public void mouseClicked(MouseEvent e) {
                    super.mouseClicked(e);
                    if (graph.mainFrame.getMode() == Mode.REMOVE_EDGE) {
                        graph.removeEdge(UndirectedEdge.this);
                    }
                }
            });
        }

        // getters

        Vertex[] getNodes() {
            return nodes;
        }

        int getWeight() {
            return weight;
        }

        JLabel getWeightLabel() {
            return weightLabel;
        }
    }
  learner_created: true
- name: src/visualizer/UndirectedEdgeCreator.java
  visible: true
  text: |
    package visualizer;

    import javax.swing.*;

    public class UndirectedEdgeCreator {
        private static Vertex fstNode = null;
        private static final String MESSAGE = "Enter Weight";
        private static final String TITLE = "Input";

        private UndirectedEdgeCreator() {
        }

        static void createUndirectedEdge(Vertex vertex) {
            if (fstNode == null) {
                fstNode = vertex;
            } else if (fstNode != vertex) {
                Integer weight = getWeight(vertex.getMainFrame().getGraph());
                if (weight == null) {
                    fstNode.getMainFrame().getGraph().whiteVertices();
                    fstNode = null;
                    return;
                }
                var undirectedEdges = vertex.getMainFrame().getGraph().getEdges();
                if (!isDuplicateEdge(undirectedEdges, vertex)) {

                    vertex.getMainFrame().getGraph()
                            .addNewEdge(new UndirectedEdge(fstNode, vertex, weight, vertex.getMainFrame().getGraph()),
                                    new UndirectedEdge(vertex, fstNode, weight, vertex.getMainFrame().getGraph()));
                    fstNode = null;
                }
            }
        }

        private static Integer getWeight(UndirectedGraph graph) {
            String input = JOptionPane.showInputDialog(graph, MESSAGE, TITLE, JOptionPane.QUESTION_MESSAGE);
            if (input == null) {
                return null;
            }
            if (isValidWeight(input)) {
                return Integer.parseInt(input);
            }
            return getWeight(graph);
        }


        private static boolean isValidWeight(String input) {
            try {
                Integer.parseInt(input);
                return true;
            } catch (IllegalArgumentException e) {
                return false;
            }
        }

        private static boolean isDuplicateEdge(java.util.Set<UndirectedEdge> edges, Vertex sndNode) {
            return edges.stream()
                    .anyMatch(edge -> edge.getNodes()[0] == fstNode && edge.getNodes()[1] == sndNode);
        }

        public static void reset() {
            fstNode = null;
        }
    }
  learner_created: true
- name: src/visualizer/Mode.java
  visible: true
  text: |
    package visualizer;

    public enum Mode {
        ADD_VERTEX("Add a Vertex"),
        ADD_EDGE("Add an Edge"),
        REMOVE_VERTEX("Remove a Vertex"),
        REMOVE_EDGE("Remove an Edge"),
        NONE_MODE("None"),
        DFS_ALGORITHM("Depth-First Search"),
        BFS_ALGORITHM("Breadth-First Search"),
        DIJKSTRA_ALGORITHM("Dijkstra's Algorithm");

        private final String name;

        Mode(String mode) {
            this.name = mode;
        }

        public String getName() {
            return name;
        }
    }
  learner_created: true
- name: src/visualizer/VertexCreator.java
  visible: true
  text: |
    package visualizer;

    import javax.swing.*;

    public class VertexCreator {
        private static final String MESSAGE = "Enter the Vertex Id (should be 1 char";
        private static final String TITLE = "Vertex";

        private VertexCreator() {
        }


        static Vertex createVertex(MainFrame mainFrame, int x, int y) {
            String input = JOptionPane.showInputDialog(mainFrame, MESSAGE, TITLE, JOptionPane.QUESTION_MESSAGE);
            if (input == null) {
                return null;
            }
            if (isValidId(input)) {
                return new Vertex(mainFrame, x, y, input.charAt(0));
            }
            return createVertex(mainFrame, x, y);
        }


        private static boolean isValidId(String input) {
            if (input.length() == 1) {
                return input.matches("[A-Za-z\\d]");
            }
            return false;
        }
    }
  learner_created: true
- name: src/visualizer/Vertex.java
  visible: true
  text: |
    package visualizer;

    import javax.swing.*;
    import java.awt.*;
    import java.awt.event.MouseAdapter;
    import java.awt.event.MouseEvent;
    import java.util.HashSet;
    import java.util.Map;
    import java.util.Set;
    import java.util.TreeMap;
    import java.util.concurrent.ExecutorService;
    import java.util.concurrent.Executors;

    public class Vertex extends JPanel {
        private static final int DIFF_X = 25;
        private static final int DIFF_Y = 25;
        private static final int SIZE = 50;

        private final MainFrame mainFrame;

        private final JLabel label = new JLabel();

        private final Map<Integer, Vertex> connectedVertices = new TreeMap<>();

        private int centerX;
        private int centerY;
        private char id;
        private static final Color DEFAULT_COLOR = Color.WHITE;
        private Color color = DEFAULT_COLOR;

        private ExecutorService executor = Executors.newSingleThreadExecutor();


        // private final int diffX = 734;  // for corner vertices apply x = (i % 2) * diffX
        // private final int diffY = 511;   // for corner vertices apply y = (i / 2) * diffY


        public Vertex(MainFrame mainFrame, int x, int y, char id) {
            this.mainFrame = mainFrame;
            this.centerX = x - DIFF_X;
            this.centerY = y - DIFF_Y;
            this.id = id;

            initComponents();
            setActionEvents();
        }

        private void initComponents() {
            setName("Vertex " + id);
            setLayout(new GridBagLayout());
            setBounds(centerX, centerY, SIZE, SIZE);

            label.setName("VertexLabel " + id);
            label.setText(String.valueOf(id));
            label.setFont(new Font("SansSerif", Font.BOLD, 40));
            label.setForeground(Color.BLACK);
            add(label);
        }

        private void setActionEvents() {
            addMouseListener(new MouseAdapter() {
                @Override
                public void mouseClicked(MouseEvent e) {
                    super.mouseClicked(e);
                    switch (mainFrame.getMode()) {
                        case ADD_VERTEX, NONE_MODE, REMOVE_EDGE -> highlight();
                        case ADD_EDGE -> createEdge();
                        case REMOVE_VERTEX -> removeVertex();
                        case DFS_ALGORITHM -> {
                            mainFrame.setResultLabelText("Please wait...");
                            executor.submit(() -> {
                                try {
                                    Thread.sleep(5000);
                                    mainFrame.setResultLabelText(new DepthFirstSearch(Vertex.this).search());
                                } catch (InterruptedException ex) {
                                    System.out.println(ex.getMessage());
                                }

                            });
                        }
                        case BFS_ALGORITHM -> {
                            mainFrame.setResultLabelText("Please wait...");
                            executor.submit(() -> {
                                try {
                                    Thread.sleep(5000);
                                    mainFrame.setResultLabelText(new BreadthFirstSearch(Vertex.this).search());
                                } catch (InterruptedException ex) {
                                    System.out.println(ex.getMessage());
                                }
                            });
                        }
                        case DIJKSTRA_ALGORITHM -> {
                            mainFrame.setResultLabelText("Please wait...");
                            executor.submit(() -> {
                                try {
                                    Thread.sleep(5000);
                                    mainFrame.setResultLabelText(new DijkstraAlgorithm(Vertex.this).search());
                                } catch (InterruptedException ex) {
                                    System.out.println(ex.getMessage());
                                }
                            });
                        }
                    }
                }
            });
        }

        @Override
        protected void paintComponent(Graphics g) {
            g.setColor(color);
            g.fillOval(0, 0, SIZE, SIZE);
        }

        private void createEdge() {
            highlight();
            UndirectedEdgeCreator.createUndirectedEdge(Vertex.this);
        }

        private void highlight() {
            mainFrame.getGraph().whiteVertices();
            color = Color.yellow;
            mainFrame.getGraph().repaint();
        }

        private void removeVertex() {
            mainFrame.getGraph().removeVertex(this);
        }

        void connectVertex(Vertex vertex, int weight) {
            connectedVertices.put(weight, vertex);
        }

        void disconnectVertex(Vertex vertex) {
            connectedVertices.remove(vertex);
        }

        // setters
        public void setX(int centerX) {
            this.centerX = centerX;
        }

        public void setY(int centerY) {
            this.centerY = centerY;
        }

        public void setId(char id) {
            this.id = id;
        }

        void setLabel(String labelText) {
            label.setText(labelText);
        }

        public void resetColor() {
            this.color = DEFAULT_COLOR;
        }

        // getters
        char getId() {
            return id;
        }

        Map<Integer, Vertex> getConnectedVertices() {
            return connectedVertices;
        }

        public int getCenterX() {
            return centerX + DIFF_X;
        }

        public int getCenterY() {
            return centerY + DIFF_Y;
        }

        public MainFrame getMainFrame() {
            return mainFrame;
        }
    }
  learner_created: true
- name: test/GraphDataOne.java
  visible: false
  text: |
    import java.util.List;

    public class GraphDataOne {

      public static List<Vertex> getVertices() {
        return List.of(
            new Vertex(175, 359, "A"),
            new Vertex(224, 176, "B"),
            new Vertex(365, 363, "C"),
            new Vertex(408, 67, "D"),
            new Vertex(531, 235, "E"),
            new Vertex(590, 64, "F")
        );
      }

      public static List<Edge> getEdges() {
        return List.of(
            new Edge("A", "B", 1),
            new Edge("B", "D", 2),
            new Edge("D", "F", 3),
            new Edge("F", "E", 4),
            new Edge("E", "C", 5),
            new Edge("C", "A", 6),
            new Edge("B", "E", 7),
            new Edge("D", "C", 8),
            new Edge("B", "C", 9),
            new Edge("D", "E", 10)
        );
      }

      public static String getDFSText() {
        return "DFS : A -> B -> D -> F -> E -> C";
      }

      public static String getBFSText() {
        return "BFS : A -> B -> C -> D -> E -> F";
      }

      public static String getDijkstraText() {
        return "B=1, C=6, D=3, E=8, F=6";
      }

      public static String getPrimText() {
        return "B=A, C=E, D=B, E=F, F=D";
      }

      public static String getSource() {
        return "A";
      }
    }
  learner_created: false
- name: src/visualizer/DepthFirstSearch.java
  visible: true
  text: |-
    package visualizer;

    import java.util.HashSet;
    import java.util.Set;

    public class DepthFirstSearch extends Algorithm {

        private Set<Vertex> searched;
        private StringBuilder ret;

        public DepthFirstSearch(Vertex startPoint) {
            super.startPoint = startPoint;
        }

        @Override
        String search() {
            ret = new StringBuilder();
            searched = new HashSet<>();
            ret.append(" ").append(startPoint.getId()).append(" ");
            searched.add(startPoint);
            dfSearch(startPoint);
            return "DFS : " + ret.toString().trim().replaceAll("\\s+", " -> ");
        }

        void dfSearch(Vertex vertex) {
            if (!searched.contains(vertex) && vertex.getConnectedVertices().isEmpty()) {
                searched.add(vertex);
                ret.append(" ").append(vertex.getId()).append(" ");
            }


            for (var vert : vertex.getConnectedVertices().values()) {
                if (!searched.contains(vert)) {
                    searched.add(vert);
                    ret.append(" ").append(vert.getId()).append(" ");
                    dfSearch(vert);
                }
            }
        }
    }
  learner_created: true
- name: test/GraphDataTwo.java
  visible: false
  text: |
    import java.util.List;

    public class GraphDataTwo {

      public static List<Vertex> getVertices() {
        return List.of(
            new Vertex(361, 54, "1"),
            new Vertex(152, 164, "2"),
            new Vertex(599, 155, "3"),
            new Vertex(47, 394, "4"),
            new Vertex(291, 392, "5"),
            new Vertex(419, 390, "6"),
            new Vertex(744, 392, "7")
        );
      }

      public static List<Edge> getEdges() {
        return List.of(
            new Edge("1", "2", 1),
            new Edge("1", "3", 3),
            new Edge("2", "4", 5),
            new Edge("5", "2", 7),
            new Edge("6", "3", 9),
            new Edge("7", "3", 11)
        );
      }

      public static String getDFSText() {
        return "DFS : 1 -> 2 -> 4 -> 5 -> 3 -> 6 -> 7";
      }

      public static String getBFSText() {
        return "BFS : 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7";
      }

      public static String getDijkstraText() {
        return "2=1, 3=3, 4=6, 5=8, 6=12, 7=14";
      }

      public static String getPrimText() {
        return "2=1, 3=1, 4=2, 5=2, 6=3, 7=3";
      }

      public static String getSource() {
        return "1";
      }
    }
  learner_created: false
- name: src/visualizer/Algorithm.java
  visible: true
  text: |
    package visualizer;

    public abstract class Algorithm {
        Vertex startPoint;

        abstract String search();
    }
  learner_created: true
- name: src/visualizer/BreadthFirstSearch.java
  visible: true
  text: |
    package visualizer;

    import java.util.*;

    public class BreadthFirstSearch extends Algorithm {
        private Set<Vertex> searched;
        private StringBuilder ret;

        private Deque<Vertex> toSearch;

        public BreadthFirstSearch(Vertex startPoint) {
            super.startPoint = startPoint;
        }

        @Override
        String search() {
            ret = new StringBuilder();
            searched = new HashSet<>();
            toSearch = new LinkedList<>();
            searched.add(startPoint);
            ret.append(" ").append(startPoint.getId()).append(" ");
            bfSearch(startPoint);
            return "BFS : " + ret.toString().trim().replaceAll("\\s+", " -> ");
        }

        void bfSearch(Vertex vertex) {
            for (var vert : vertex.getConnectedVertices().values()) {
                if (!searched.contains(vert)) {
                    toSearch.addLast(vert);
                }
            }
            doSearch();
        }

        void doSearch() {
            while (!toSearch.isEmpty()) {
                var vertex = toSearch.pollFirst();
                if (!searched.contains(vertex)) {
                    ret.append(" ").append(vertex.getId()).append(" ");
                    searched.add(vertex);
                    bfSearch(vertex);
                }
            }
        }
    }
  learner_created: true
- name: src/visualizer/DijkstraAlgorithm.java
  visible: true
  text: |
    package visualizer;

    import java.util.HashSet;
    import java.util.LinkedHashMap;
    import java.util.Map;
    import java.util.Set;

    public class DijkstraAlgorithm extends Algorithm {

        private Map<Vertex, Integer> weights;

        public DijkstraAlgorithm(Vertex startPoint) {
            super.startPoint = startPoint;
        }

        private int count = 1;

        @Override
        String search() {
            weights = new LinkedHashMap<>();
            weights.put(startPoint, 0);

            findShortestPath(startPoint, Set.of(startPoint));

            weights.remove(startPoint);

            StringBuilder ret = new StringBuilder();
            weights.forEach((k, v) -> ret.append(k.getId()).append("=").append(v).append(", "));
            return ret.deleteCharAt(ret.length() - 2).toString().trim();
        }

        void findShortestPath(Vertex vertex, Set<Vertex> parents) {
            var tmpMap = new LinkedHashMap<Vertex, Integer>();
            for (var entry : vertex.getConnectedVertices().entrySet()) {
                tmpMap.put(entry.getValue(), entry.getKey());
            }
            for (var entry : tmpMap.entrySet()) {
                if (entry.getKey() != startPoint && entry.getKey() != vertex && !parents.contains(entry.getKey())) {
                    int vertWeight = weights.get(vertex) + entry.getValue();
                    weights.put(entry.getKey(), Math.min(vertWeight, weights.getOrDefault(entry.getKey(), Integer.MAX_VALUE)));
                    System.out.println("p1 " + count + " " + entry.getKey().getName());
                    count++;
                }
            }

            for (var entry : tmpMap.entrySet()) {
                if (entry.getKey() != startPoint && entry.getKey() != vertex && !parents.contains(entry.getKey())) {
                    System.out.println("p2 " + count + " " + entry.getKey().getName());
                    var tmpSet = new HashSet<>(parents);
                    tmpSet.add(vertex);
                    findShortestPath(entry.getKey(), tmpSet);
                }
            }
        }
    }
  learner_created: true
- name: test/_4_RemoveVertexEdgeTests.java
  visible: false
  text: |
    import org.assertj.swing.fixture.JLabelFixture;
    import org.assertj.swing.fixture.JMenuItemFixture;
    import org.assertj.swing.fixture.JPanelFixture;
    import org.hyperskill.hstest.dynamic.DynamicTest;
    import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
    import org.hyperskill.hstest.stage.SwingTest;
    import org.hyperskill.hstest.testcase.CheckResult;
    import org.hyperskill.hstest.testing.swing.SwingComponent;
    import visualizer.MainFrame;

    import java.util.ArrayList;
    import java.util.List;
    import java.util.Objects;

    @SuppressWarnings("unused")
    public class _4_RemoveVertexEdgeTests extends SwingTest {

      @SwingComponent
      private JPanelFixture graph;

      @SwingComponent(name = "Mode")
      JLabelFixture mode;

      @SwingComponent(name = "Add a Vertex")
      JMenuItemFixture addVertexMenuItem;

      @SwingComponent(name = "Add an Edge")
      JMenuItemFixture addEdgeMenuItem;

      @SwingComponent(name = "Remove a Vertex")
      JMenuItemFixture removeVertexMenuItem;

      @SwingComponent(name = "Remove an Edge")
      JMenuItemFixture removeEdgeMenuItem;

      private final List<Vertex> vertices = new ArrayList<>(List.of(
          new Vertex(386, 221, "0"),
          new Vertex(211, 216, "1"),
          new Vertex(245, 92, "2"),
          new Vertex(372, 28, "3"),
          new Vertex(512, 81, "4"),
          new Vertex(543, 215, "5"),
          new Vertex(499, 345, "6"),
          new Vertex(372, 407, "7"),
          new Vertex(233, 349, "8")
      ));

      private final List<Edge> edges = new ArrayList<>(List.of(
          new Edge("0", "1", 1),
          new Edge("0", "2", 1),
          new Edge("0", "3", 2),
          new Edge("0", "4", 3),
          new Edge("0", "5", 4),
          new Edge("0", "6", 5),
          new Edge("0", "7", 6),
          new Edge("0", "8", 7),
          new Edge("1", "2", 3),
          new Edge("2", "3", 4),
          new Edge("3", "4", 5),
          new Edge("4", "5", 6),
          new Edge("5", "6", 7),
          new Edge("6", "7", 3),
          new Edge("7", "8", 4),
          new Edge("8", "1", 5)
      ));

      public _4_RemoveVertexEdgeTests() {
        super(new MainFrame());
      }

      @DynamicTest(order = 1, feedback = "Could not insert vertices")
      CheckResult insertVertices() {
        addVertexMenuItem.click();
        for (var v : vertices) {
          _2_VertexTests.assertSuccessfulVertexInsertion(graph, v.getX(), v.getY(), v.getId(), getWindow().robot());
        }
        return CheckResult.correct();
      }

      @DynamicTest(order = 2, feedback = "Could not insert edges")
      CheckResult insertEdges() {
        addEdgeMenuItem.click();
        TestingUtils.addEdge(edges, graph, getWindow().robot());
        return CheckResult.correct();
      }

      @DynamicTest(order = 3, feedback = "Could not Remove an Edge <8 -> 1> or Edge <4 -> 5>")
      CheckResult removeTwoEdges() {
        removeEdgeMenuItem.click();
        var edge_8_1 = getEdge("8", "1").getMidPoint(getVertex("8").asPoint(), getVertex("1").asPoint());
        var edge_5_6 = getEdge("4", "5").getMidPoint(getVertex("4").asPoint(), getVertex("5").asPoint());
        getWindow().robot().click(graph.target().getComponentAt(edge_8_1));
        getWindow().robot().click(graph.target().getComponentAt(edge_5_6));
        return CheckResult.correct();
      }

      @DynamicTest(order = 4, feedback = "Edge still exists in the graph (JPanel) after removing them.")
      CheckResult checkRemoveTwoEdges() {
        var msg = " still exists in the graph after removing.";
        var edgeNameFormat = "Edge <%d -> %d>";
        var edge_8_1 = String.format(edgeNameFormat, 8, 1);
        var edge_1_8 = String.format(edgeNameFormat, 1, 8);
        var edge_4_5 = String.format(edgeNameFormat, 4, 5);
        var edge_5_4 = String.format(edgeNameFormat, 5, 4);

        for (var c : getAllComponents(graph.target())) {
          if (Objects.equals(edge_8_1, c.getName()) || Objects.equals(edge_1_8, c.getName()))
            throw new WrongAnswer(edge_8_1 + " or " + edge_1_8 + msg);

          if (Objects.equals(edge_4_5, c.getName()) || Objects.equals(edge_5_4, c.getName()))
            throw new WrongAnswer(edge_4_5 + " or " + edge_5_4 + msg);
        }

        edges.removeIf(e -> (e.getFrom().equals("8") && e.getTo().equals("1")) ||
            (e.getFrom().equals("4") && e.getTo().equals("5")));

        return CheckResult.correct();
      }

      @DynamicTest(order = 5, feedback = "Wrong number of components in Graph")
      CheckResult validateNumberOfComponents() {
        return TestingUtils.assertComponentCount(graph,
            vertices.size() + 3 * edges.size());
      }

      @DynamicTest(order = 6, feedback = "Could not delete vertices")
      CheckResult deleteTwoVertices() {
        removeVertexMenuItem.click();
        var vertex_0 = getVertex("0").asPoint();
        var vertex_7 = getVertex("7").asPoint();
        getWindow().robot().click(graph.target().getComponentAt(vertex_0));
        getWindow().robot().click(graph.target().getComponentAt(vertex_7));
        return CheckResult.correct();
      }

      @DynamicTest(order = 7, feedback = "All of the in and out edges of the vertex must be deleted along with the vertices")
      CheckResult checkDeleteResult() {
        var feedbackText = "Already deleted Vertex %s is present in the graph.";
        for (var c : getAllComponents(graph.target())) {

          if (Objects.equals("Vertex " + 0, c.getName())) {
            throw new WrongAnswer(String.format(feedbackText, 0));
          } else if (Objects.equals("Vertex " + 7, c.getName())) {
            throw new WrongAnswer(String.format(feedbackText, 7));
          } else if (c.getName().matches("Edge <0 -> .>") ||
              c.getName().matches("Edge <. -> 0>") ||
              c.getName().matches("Edge <7 -> .>") ||
              c.getName().matches("Edge <. -> 7>")) {
            throw new WrongAnswer("In or Out edges of the deleted vertex shall be removed too.");
          }
        }

        vertices.removeIf(v -> v.getId().equals("7") || v.getId().equals("0"));

        edges.removeIf(e -> e.getFrom().equals("0") ||
            e.getTo().equals("0") ||
            e.getFrom().equals("7") ||
            e.getTo().equals("7"));

        return CheckResult.correct();
      }

      @DynamicTest(order = 8, feedback = "Incorrect number of components in graph after deleting edges and vertices")
      CheckResult componentCheckAfterRemove() {
        return TestingUtils.assertComponentCount(graph, vertices.size() + 3 * edges.size());
      }

      @DynamicTest(order = 9, feedback = "Error removing vertex and edges")
      CheckResult deleteAllComponents() {
        var robot = getWindow().robot();
        for (var v : vertices) {
          robot.click(graph.target().getComponentAt(v.asPoint()));
        }

        for (var e : edges) {
          robot.click(graph.target()
              .getComponentAt(
                  e.getMidPoint(
                      getVertex(e.getFrom())
                          .asPoint(),
                      getVertex(e.getTo()).asPoint())
              )
          );
        }

        return CheckResult.correct();
      }

      @DynamicTest(order = 10, feedback = "After deleting all component, JPanel Graph is not empty")
      CheckResult checkEmpty() {
        return TestingUtils.assertComponentCount(graph, 0);
      }

      private Vertex getVertex(String id) {
        return vertices
            .stream()
            .filter(v -> v.getId().equals(id))
            .findFirst()
            .orElseThrow();
      }

      private Edge getEdge(String from, String to) {
        return edges
            .stream()
            .filter(e -> e.getFrom().equals(from) && e.getTo().equals(to))
            .findFirst()
            .orElseThrow();
      }
    }
  learner_created: false
- name: test/_5_GraphAlgorithmTests.java
  visible: false
  text: |
    import org.assertj.swing.exception.WaitTimedOutError;
    import org.assertj.swing.fixture.JLabelFixture;
    import org.assertj.swing.fixture.JMenuItemFixture;
    import org.assertj.swing.fixture.JOptionPaneFixture;
    import org.assertj.swing.fixture.JPanelFixture;
    import org.hyperskill.hstest.common.Utils;
    import org.hyperskill.hstest.dynamic.DynamicTest;
    import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
    import org.hyperskill.hstest.stage.SwingTest;
    import org.hyperskill.hstest.testcase.CheckResult;
    import org.hyperskill.hstest.testing.swing.SwingComponent;
    import visualizer.MainFrame;

    import javax.swing.*;

    import java.util.Objects;

    import static org.hyperskill.hstest.testcase.CheckResult.correct;
    import static org.hyperskill.hstest.testcase.CheckResult.wrong;

    @SuppressWarnings("unused")
    @DynamicTest()
    public class _5_GraphAlgorithmTests extends SwingTest {

      @SwingComponent
      private JPanelFixture graph;

      @SwingComponent(name = "Mode")
      private JLabelFixture mode;

      @SwingComponent
      private JLabelFixture display;

      @SwingComponent(name = "New")
      private JMenuItemFixture newMenuItem;

      @SwingComponent(name = "Exit")
      private JMenuItemFixture exitMenuItem;

      @SwingComponent(name = "Add a Vertex")
      private JMenuItemFixture addVertexMenuItem;

      @SwingComponent(name = "Add an Edge")
      private JMenuItemFixture addEdgeMenuItem;

      @SwingComponent(name = "Remove a Vertex")
      private JMenuItemFixture removeVertexMenuItem;

      @SwingComponent(name = "Remove an Edge")
      private JMenuItemFixture removeEdgeMenuItem;

      @SwingComponent(name = "None")
      private JMenuItemFixture noneMenuItem;

      @SwingComponent(name = "Depth-First Search")
      private JMenuItemFixture dfs;

      @SwingComponent(name = "Breadth-First Search")
      private JMenuItemFixture bfs;

      @SwingComponent(name = "Dijkstra's Algorithm")
      private JMenuItemFixture dijkstra;

      @SwingComponent(name = "Prim's Algorithm")
      private JMenuItemFixture prim;

      public _5_GraphAlgorithmTests() {
        super(new MainFrame());
      }

      private CheckResult getAddVertexCheckResult(java.util.List<Vertex> vertices) {
        var robot = getWindow().robot();
        for (var v : vertices) {
          robot.click(graph.target(), v.asPoint());

          JOptionPaneFixture dialog;
          try {
            dialog = TestingUtils.getOptionPaneFixture(getWindow().robot());
          } catch (WaitTimedOutError e) {
            throw new WrongAnswer(e.getMessage());
          }
          dialog.textBox().setText(v.getId());
          dialog.okButton().click();
        }

        var components = graph.target().getComponents().length;
        var noOfVertices = vertices.size();
        if (components != noOfVertices)
          return wrong(String.format("%d vertices was expected to be present, but found %d", noOfVertices, components));
        return correct();
      }


      private CheckResult getAddEdgesCheckResult(java.util.List<Edge> edges) {
        var robot = getWindow().robot();
        return TestingUtils.addEdge(edges, graph, robot);
      }

      private void runAlgorithm(String source) {
        if (!Objects.equals("Please choose a starting vertex", display.text()))
          throw new WrongAnswer("After clicking on any algorithm, display JLabel must show - " +
              "\"Please choose a starting vertex\"");
        new JPanelFixture(getWindow().robot(), (JPanel) TestingUtils.getVertex(source, graph)).click();
        display.requireText("Please wait...");
      }

      private CheckResult getAlgorithmCheckResult(String feedback, String expected) {
        if (!Objects.equals(display.text(), expected))
          throw new WrongAnswer(feedback +
              " Expected : \"" + expected + "\", but got : \"" + display.text() + "\"");

        return correct();
      }

      private void waitForCompletion() {
        int totalTime = 0;
        while (Objects.equals(display.text(), "Please wait...")) {
          if (totalTime > 60000) {
            throw new WrongAnswer("Algorithm Running for more than 1 min");
          }
          Utils.sleep(100);
          totalTime += 100;
        }
      }

      @DynamicTest(order = 1, feedback = "Initial Mode must be \"Add a Vertex\"")
      CheckResult checkDefaultMode() {
        newMenuItem.click();
        if (mode.text()== null || !mode.text().contains("Add a Vertex"))
          return wrong("Expected Mode \"Add a Vertex\", Got : " + mode.text());
        return correct();
      }

      @DynamicTest(order = 2, feedback = "Vertices could not be inserted")
      CheckResult insertVertices() {
        var vertices = GraphDataOne.getVertices();
        return getAddVertexCheckResult(vertices);
      }

      @DynamicTest(order = 3, feedback = "Edges could not be inserted")
      CheckResult insertEdges() {
        addEdgeMenuItem.click();
        var edges = GraphDataOne.getEdges();
        return getAddEdgesCheckResult(edges);
      }

      @DynamicTest(order = 4, feedback = "Failed to run DFS Algorithm")
      CheckResult depthFirstSearchTraversal() {
        dfs.click();
        runAlgorithm(GraphDataOne.getSource());

        waitForCompletion();

        return getAlgorithmCheckResult("Wrong Answer in DFS Traversal.",
            GraphDataOne.getDFSText());
      }

      @DynamicTest(order = 5, feedback = "Failed to run BFS Algorithm")
      CheckResult breadthFirstSearchTraversal() {
        bfs.click();
        runAlgorithm(GraphDataOne.getSource());

        waitForCompletion();

        return getAlgorithmCheckResult("Wrong Answer in BFS Traversal.",
            GraphDataOne.getBFSText());
      }

      @DynamicTest(order = 6, feedback = "Failed to run Dijkstra's Algorithm")
      CheckResult dijkstraShortestPathAlgorithm() {
        dijkstra.click();
        runAlgorithm(GraphDataOne.getSource());

        waitForCompletion();

        return getAlgorithmCheckResult("Wrong Answer in Dijkstra's Algorithm.",
            GraphDataOne.getDijkstraText());
      }

      @DynamicTest(order = 7, feedback = "Failed to run Prim's Algorithm")
      CheckResult primsMinimumSpanningTree() {
        prim.click();
        runAlgorithm(GraphDataOne.getSource());

        waitForCompletion();

        return getAlgorithmCheckResult("Wrong Answer in Prim's Algorithm.",
            GraphDataOne.getPrimText());
      }

      @DynamicTest(order = 8, feedback = "Vertices could not be inserted")
      CheckResult insertVertices2() {
        newMenuItem.click();
        var vertices = GraphDataTwo.getVertices();
        return getAddVertexCheckResult(vertices);
      }

      @DynamicTest(order = 9, feedback = "Edges could not be inserted")
      CheckResult insertEdges2() {
        addEdgeMenuItem.click();
        var edges = GraphDataTwo.getEdges();
        return getAddEdgesCheckResult(edges);
      }

      @DynamicTest(order = 10, feedback = "Failed to run DFS Algorithm")
      CheckResult depthFirstSearchTraversal2() {
        dfs.click();
        runAlgorithm(GraphDataTwo.getSource());

        waitForCompletion();

        return getAlgorithmCheckResult("Wrong Answer in DFS Traversal.",
            GraphDataTwo.getDFSText());
      }

      @DynamicTest(order = 11, feedback = "Failed to run BFS Algorithm")
      CheckResult breadthFirstSearchTraversal2() {
        bfs.click();
        runAlgorithm(GraphDataTwo.getSource());

        waitForCompletion();

        return getAlgorithmCheckResult("Wrong Answer in BFS Traversal.",
            GraphDataTwo.getBFSText());
      }

      @DynamicTest(order = 12, feedback = "Failed to run Dijkstra's Algorithm")
      CheckResult dijkstraShortestPathAlgorithm2() {
        dijkstra.click();
        runAlgorithm(GraphDataTwo.getSource());

        waitForCompletion();

        return getAlgorithmCheckResult("Wrong Answer in Dijkstra's Algorithm.",
            GraphDataTwo.getDijkstraText());
      }

      @DynamicTest(order = 13, feedback = "Failed to run Prim's Algorithm")
      CheckResult primsMinimumSpanningTree2() {
        prim.click();
        runAlgorithm(GraphDataTwo.getSource());

        waitForCompletion();

        return getAlgorithmCheckResult("Wrong Answer in Prim's Algorithm.",
            GraphDataTwo.getPrimText());
      }
    }
  learner_created: false
- name: test/_1_InitialTests.java
  visible: false
  text: |
    import org.assertj.swing.exception.WaitTimedOutError;
    import org.assertj.swing.finder.WindowFinder;
    import org.assertj.swing.fixture.JLabelFixture;
    import org.assertj.swing.fixture.JMenuItemFixture;
    import org.assertj.swing.fixture.JPanelFixture;
    import org.hyperskill.hstest.dynamic.DynamicTest;
    import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
    import org.hyperskill.hstest.stage.SwingTest;
    import org.hyperskill.hstest.testcase.CheckResult;
    import org.hyperskill.hstest.testing.swing.SwingComponent;
    import visualizer.MainFrame;

    import static org.hyperskill.hstest.testcase.CheckResult.correct;
    import static org.hyperskill.hstest.testcase.CheckResult.wrong;

    @SuppressWarnings("unused")
    public class _1_InitialTests extends SwingTest {

      @SwingComponent
      JPanelFixture graph;

      @SwingComponent(name = "Exit")
      JMenuItemFixture exitMenuItem;

      @SwingComponent(name = "Add a Vertex")
      JMenuItemFixture addVertexMenuItem;

      @SwingComponent(name = "Add an Edge")
      JMenuItemFixture addEdgeMenuItem;

      @SwingComponent(name = "Remove a Vertex")
      JMenuItemFixture removeVertexMenuItem;

      @SwingComponent(name = "Remove an Edge")
      JMenuItemFixture removeEdgeMenuItem;

      @SwingComponent(name = "None")
      JMenuItemFixture noneMenuItem;

      @SwingComponent(name = "Mode")
      JLabelFixture mode;

      public _1_InitialTests() {
        super(new MainFrame());
      }

      @DynamicTest(order = 1, feedback = "Either title (Expected: \"Graph-Algorithms Visualizer\") or " +
          "the dimension of the frame (Expected: 800 x 600) is incorrect")
      CheckResult checkTitleAndDimension() {
        if (!frame.getTitle().equals("Graph-Algorithms Visualizer"))
          throw new WrongAnswer("Title of the frame must be \"Graph-Algorithms Visualizer\" " +
              "but instead got - \"" + frame.getTitle() + "\"");
        if (!(frame.getHeight() == 600 && frame.getWidth() == 800)) {
          throw new WrongAnswer("Frame Dimension should be (w=800, h=600)");
        }
        return correct();
      }

      @DynamicTest(order = 2, feedback = "Could not check components. " +
          "Make sure there's no components in the graph initially")
      CheckResult checkForEmptyGraphPanel() {
        return TestingUtils.assertComponentCount(graph, 0);
      }

      @DynamicTest(order = 3, feedback = "Could not change mode.")
      CheckResult checkForModeChanges() {
        addVertexMenuItem.click();
        modeCheck("Add a Vertex");

        removeVertexMenuItem.click();
        modeCheck("Remove a Vertex");

        addEdgeMenuItem.click();
        modeCheck("Add an Edge");

        removeEdgeMenuItem.click();
        modeCheck("Remove an Edge");

        noneMenuItem.click();
        modeCheck("None");

        return correct();
      }

      @DynamicTest(order = 4)
      CheckResult exitCheck() {
        exitMenuItem.click();
        try {
          var frameFixture = WindowFinder
              .findFrame("Graph-Algorithms Visualizer")
              .withTimeout(200)
              .using(getWindow().robot());
        } catch (WaitTimedOutError e) {
          return correct();
        }
        return wrong("Window is not closed after clicking on the exit menu item.");
      }

      private void modeCheck(String text) {
        var msg = "After clicking on \"%s\" Menu Item, the mode (JLabel) should should be \"%s\". Got : \"%s\"";

        if (mode.text() == null || !mode.text().contains(text))
          throw new WrongAnswer(String.format(msg, text, text, mode.text()));
      }
    }
  learner_created: false
- name: test/Edge.java
  visible: false
  text: |
    import java.awt.*;

    public final class Edge {
      private final String from;
      private final String to;
      private final int weight;

      public Edge(String from, String to, int weight) {
        this.from = from;
        this.to = to;
        this.weight = weight;
      }

      public String getFrom() {
        return from;
      }

      public String getTo() {
        return to;
      }

      public int getWeight() {
        return weight;
      }

      public Point getMidPoint(Point from, Point to) {
        int x = (int) ((from.getX() + to.getX()) / 2);
        int y = (int) ((from.getY() + to.getY()) / 2);
        return new Point(x, y);
      }
    }
  learner_created: false
- name: src/visualizer/PrimAlgorithm.java
  visible: true
  learner_created: true
- name: test/Vertex.java
  visible: false
  text: |
    import java.awt.*;

    public final class Vertex {
      private final int x;
      private final int y;
      private final String id;

      public Vertex(int x, int y, String id) {
        this.x = x;
        this.y = y;
        this.id = id;
      }

      public int getX() {
        return x;
      }

      public int getY() {
        return y;
      }


      public String getId() {
        return id;
      }

      public Point asPoint() {
        return new Point(getX(), getY());
      }
    }
  learner_created: false
- name: src/visualizer/SearchStrategy.java
  visible: true
  learner_created: true
- name: test/_2_VertexTests.java
  visible: false
  text: |
    import org.assertj.swing.core.Robot;
    import org.assertj.swing.exception.ComponentLookupException;
    import org.assertj.swing.exception.WaitTimedOutError;
    import org.assertj.swing.finder.JOptionPaneFinder;
    import org.assertj.swing.fixture.JLabelFixture;
    import org.assertj.swing.fixture.JMenuItemFixture;
    import org.assertj.swing.fixture.JOptionPaneFixture;
    import org.assertj.swing.fixture.JPanelFixture;
    import org.hyperskill.hstest.dynamic.DynamicTest;
    import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
    import org.hyperskill.hstest.stage.SwingTest;
    import org.hyperskill.hstest.testcase.CheckResult;
    import org.hyperskill.hstest.testing.swing.SwingComponent;
    import visualizer.MainFrame;

    import javax.swing.*;
    import java.awt.*;
    import java.util.List;

    import static org.hyperskill.hstest.testcase.CheckResult.correct;

    @SuppressWarnings("unused")
    public class _2_VertexTests extends SwingTest {

      @SwingComponent
      JPanelFixture graph;

      @SwingComponent(name = "New")
      JMenuItemFixture newMenuItem;

      @SwingComponent(name = "Mode")
      JLabelFixture mode;

      @SwingComponent(name = "Add a Vertex")
      JMenuItemFixture addVertexMenuItem;

      @SwingComponent(name = "Add an Edge")
      JMenuItemFixture addEdgeMenuItem;

      @SwingComponent(name = "Remove a Vertex")
      JMenuItemFixture removeVertexMenuItem;

      @SwingComponent(name = "Remove an Edge")
      JMenuItemFixture removeEdgeMenuItem;

      @SwingComponent(name = "None")
      JMenuItemFixture noneMenuItem;

      public _2_VertexTests() {
        super(new MainFrame());
      }

      @DynamicTest(order = 1)
      CheckResult checkDialogAppearing() {
        addVertexMenuItem.click();
        graph.click();

        try {

          testDialog("");
          testDialog("123");
          testDialog("ABC");
          cancelDialog();
          graph.click();
          testDialog("0");

        } catch (WaitTimedOutError wt) {
          throw new WrongAnswer("Could not find a dialog box after clicking on the graph panel.");
        } catch (ComponentLookupException cl) {
          throw new WrongAnswer("A ok button, cancel button and a text field must be present inside the dialog");
        } catch (IllegalStateException e) {
          throw new WrongAnswer("Either the text field is disabled or it is not showing on the screen.");
        } catch (Exception e) {
          throw new WrongAnswer("Something went wrong. Please read the instructions carefully and try again.");
        }

        return TestingUtils.assertComponentCount(graph, 1);
      }

      @DynamicTest(order = 2)
      CheckResult addVertices() {
        for (var pos : getVertexTestingPositions()) {
          assertSuccessfulVertexInsertion(graph,
              pos.getX(),
              pos.getY(),
              pos.getId(),
              getWindow().robot());
        }
        return correct();
      }

      @DynamicTest(order = 3)
      CheckResult checkComponentsAfterVertexInsertions() {
        return TestingUtils.assertComponentCount(graph, 8);
      }

      @DynamicTest(order = 4, feedback = "There's a problem with VertexLabel (JLabel)")
      CheckResult checkVertexLabels() {
        int flag = 0;
        for (var component : getAllComponents(graph.target())) {
          if (component instanceof JLabel && component.getName().startsWith("VertexLabel ")) {
            var labelName = component.getName().replace("VertexLabel ", "");
            var componentName = component.getParent().getName().replace("Vertex ", "");
            if (!(labelName.equals(componentName))) {
              throw new WrongAnswer("All of the vertices must contain " +
                  "a JLabel with name as \"VertexLabel <id>\" and text as \"<id>\" in it.");
            }
            if (!component.getParent().getName().startsWith("Vertex "))
              throw new WrongAnswer("All VertexLabel must be inside of Vertex (JPanel)");
            flag++;
          }
        }
        if (flag != getVertexTestingPositions().size() + 1) {
          throw new WrongAnswer("All of the vertices must contain " +
              "a JLabel with name as \"VertexLabel <id>\" and text as \"<id>\" in it.");
        }
        return correct();
      }

      @DynamicTest(order = 6, feedback = "Graph panel should be empty after clicking on new menu item (JMenuItem)")
      CheckResult checkForEmptyGraphAfterClickingNewMenuItem() {
        newMenuItem.click();

        if (mode.text() == null && !mode.text().contains("Add a Vertex"))
          throw new WrongAnswer("Mode should be \"Add a Vertex\" after " +
              "clicking on new menu item. Found : " + mode.text());

        if (graph.target().getComponents().length != 0)
          throw new WrongAnswer("Graph panel should not contain anything " +
              "after clicking on new menu item. Found : " + graph.target().getComponents().length);

        return correct();
      }

      @DynamicTest(order = 7)
      CheckResult checkVertexInsertionInNoneMode() {
        noneMenuItem.click();
        return checkVertexInsertionInOtherModes();
      }

      @DynamicTest(order = 8)
      CheckResult checkVertexInsertionInAddEdgeMode() {
        addEdgeMenuItem.click();
        return checkVertexInsertionInOtherModes();
      }

      @DynamicTest(order = 9)
      CheckResult checkVertexInsertionInRemoveEdgeMode() {
        removeEdgeMenuItem.click();
        return checkVertexInsertionInOtherModes();
      }

      @DynamicTest(order = 10)
      CheckResult checkVertexInsertionInRemoveVertexMode() {
        removeVertexMenuItem.click();
        return checkVertexInsertionInOtherModes();
      }

      private CheckResult checkVertexInsertionInOtherModes() {
        getWindow().robot().click(graph.target(), new Point(100, 200));
        try {
          JOptionPaneFinder
              .findOptionPane()
              .withTimeout(200)
              .using(getWindow().robot());
          throw new WrongAnswer("Vertex adding process should only " +
              "be initiated in \"Add a Vertex\" mode. Current Mode: " + mode.text());
        } catch (WaitTimedOutError e) {
          return correct();
        }
      }

      public static List<Vertex> getVertexTestingPositions() {
        return List.of(
            new Vertex(116, 108, "1"),
            new Vertex(579, 238, "9"),
            new Vertex(671, 91, "A"),
            new Vertex(290, 309, "H"),
            new Vertex(581, 360, "N"),
            new Vertex(551, 72, "Y"),
            new Vertex(698, 249, "Z")
        );
      }

      public static void assertSuccessfulVertexInsertion(JPanelFixture graph, int x, int y, String id, Robot robot) {
        robot.click(graph.target(), new Point(x, y));
        JOptionPaneFixture dialog;
        try {
          dialog = TestingUtils.getOptionPaneFixture(robot);
        } catch (WaitTimedOutError e) {
          throw new WrongAnswer(e.getMessage());
        }

        dialog
            .textBox()
            .setText(id);

        if (!dialog.textBox().text().equals(id))
          throw new WrongAnswer(
              String.format("Content of the text field inside the dialog box must be " +
                  "filled with the content after filling. Expected: \"%s\", Got: \"%s\"", id, dialog.textBox().text()));

        dialog
            .okButton()
            .click();


        boolean flag = false;
        var feedbackText = String.format("Graph Panel should contain a vertex with name \"Vertex %s\" " +
            "after a successful insertion.", id);

        for (var vertex : getAllComponents(graph.target())) {
          if (vertex.getName().equals("Vertex " + id) && vertex instanceof JComponent) {
            if (!(vertex.getX() == (x - 25) && vertex.getY() == (y - 25)))
              throw new WrongAnswer(
                  String.format("Incorrect position of Vertex %s -> (%d, %d), Expected position -> (%s, %s).",
                      id, vertex.getX(), vertex.getY(), x, y));
            flag = true;
            break;
          }
        }
        if (!flag)
          throw new WrongAnswer(feedbackText);
      }

      private void cancelDialog() {
        JOptionPaneFixture dialog;
        try {
          dialog = TestingUtils.getOptionPaneFixture(getWindow().robot());
        } catch (WaitTimedOutError e) {
          throw new WrongAnswer(e.getMessage());
        }

        dialog.cancelButton().click();
      }

      private void testDialog(String s) {
        JOptionPaneFixture dialog;
        try {
          dialog = TestingUtils.getOptionPaneFixture(getWindow().robot());
        } catch (WaitTimedOutError e) {
          throw new WrongAnswer(e.getMessage());
        }

        dialog.textBox()
            .setText(s);

        dialog.okButton().click();
      }
    }
  learner_created: false
- name: test/_3_EdgesTests.java
  visible: false
  text: |
    import org.assertj.swing.exception.WaitTimedOutError;
    import org.assertj.swing.fixture.JLabelFixture;
    import org.assertj.swing.fixture.JMenuItemFixture;
    import org.assertj.swing.fixture.JOptionPaneFixture;
    import org.assertj.swing.fixture.JPanelFixture;
    import org.hyperskill.hstest.dynamic.DynamicTest;
    import org.hyperskill.hstest.exception.outcomes.TestPassed;
    import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
    import org.hyperskill.hstest.stage.SwingTest;
    import org.hyperskill.hstest.testcase.CheckResult;
    import org.hyperskill.hstest.testing.swing.SwingComponent;
    import visualizer.MainFrame;

    import javax.swing.*;
    import java.util.HashMap;
    import java.util.List;
    import java.util.Map;

    import static org.hyperskill.hstest.testcase.CheckResult.correct;
    import static org.hyperskill.hstest.testcase.CheckResult.wrong;

    @SuppressWarnings("unused")
    public class _3_EdgesTests extends SwingTest {

      @SwingComponent
      JPanelFixture graph;

      @SwingComponent(name = "Mode")
      JLabelFixture mode;

      @SwingComponent(name = "Add a Vertex")
      JMenuItemFixture addVertexMenuItem;

      @SwingComponent(name = "Add an Edge")
      JMenuItemFixture addEdgeMenuItem;

      @SwingComponent(name = "Remove a Vertex")
      JMenuItemFixture removeVertexMenuItem;

      @SwingComponent(name = "Remove an Edge")
      JMenuItemFixture removeEdgeMenuItem;

      @SwingComponent(name = "None")
      JMenuItemFixture noneMenuItem;

      public _3_EdgesTests() {
        super(new MainFrame());
      }

      public static List<Vertex> getEdgeTestingVertexPositions() {
        return List.of(
            new Vertex(175, 359, "A"),
            new Vertex(224, 176, "B"),
            new Vertex(365, 363, "C"),
            new Vertex(408, 67, "D"),
            new Vertex(531, 235, "E"),
            new Vertex(590, 64, "F")
        );
      }

      @DynamicTest(feedback = "Could not insert vertices")
      CheckResult addVerticesForTestingEdges() {
        addVertexMenuItem.click();

        for (var v : getEdgeTestingVertexPositions()) {
          _2_VertexTests.assertSuccessfulVertexInsertion(graph, v.getX(), v.getY(), v.getId(), getWindow().robot());
        }
        return correct();
      }

      public static Map<String, Vertex> getVertexEdgeTestingPositionsAsMap() {
        Map<String, Vertex> map = new HashMap<>();
        for (var item : getEdgeTestingVertexPositions()) {
          map.put(item.getId(), item);
        }
        return map;
      }

      public static List<Edge> getEdgeTestingPositions() {
        return List.of(
            new Edge("A", "B", 1),
            new Edge("B", "D", 2),
            new Edge("D", "F", 3),
            new Edge("F", "E", 4),
            new Edge("E", "C", 5),
            new Edge("C", "A", 6),
            new Edge("B", "E", 7),
            new Edge("D", "C", 8),
            new Edge("B", "C", 9),
            new Edge("D", "E", 10)
        );
      }

      @DynamicTest(order = 1, feedback = "Error while adding edges")
      CheckResult test15() {
        var map = getVertexEdgeTestingPositionsAsMap();
        var target = graph.target();

        addEdgeMenuItem.click();

        for (var e : getEdgeTestingPositions()) {

          var v = e.getFrom();
          var u = e.getTo();

          var fixtureV = getVertexPanelFixture(map, target, v);
          var fixtureU = getVertexPanelFixture(map, target, u);
          fixtureV.click();
          fixtureU.click();

          var dialog = TestingUtils.getOptionPaneFixture(getWindow().robot());
          dialog.textBox().setText(e.getWeight() + "");
          dialog.okButton().click();

          checkEdge(v, u, true);
          checkEdge(u, v, true);
          checkEdgeLabel(v, u, e.getWeight(), true);
        }

        return correct();
      }

      @DynamicTest(order = 2)
      CheckResult componentCountCheckupAfterAddingEdges() {
        return TestingUtils.assertComponentCount(
            graph,
            getEdgeTestingVertexPositions().size() +
                3 * getEdgeTestingPositions().size()
        );
      }

      @DynamicTest(order = 3, feedback = "Inclusion of Edges Error")
      CheckResult checkInclusionOfEdgesInIncorrectModes() {
        Map<String, Vertex> map = getVertexEdgeTestingPositionsAsMap();
        var target = graph.target();

        try {

          removeVertexMenuItem.click();
          tryToIncludeTwoArbitraryEdges(map, target);

          noneMenuItem.click();
          tryToIncludeTwoArbitraryEdges(map, target);

          removeEdgeMenuItem.click();
          tryToIncludeTwoArbitraryEdges(map, target);
        } catch (WaitTimedOutError e) {
          throw new TestPassed();
        }

        return wrong("Edges can only be added in \"Add an Edge\" mode. Found Mode : " + mode.text());
      }

      private JPanelFixture getVertexPanelFixture(Map<String, Vertex> map, JPanel target, String v) {
        return new JPanelFixture(getWindow().robot(), (JPanel) target.getComponentAt(map.get(v).asPoint()));
      }

      private void checkEdgeLabel(String v, String u, int weight, boolean value) {
        boolean foundEdgeLabel = false;
        for (var e : getAllComponents(graph.target())) {
          if (e.getName() == null)
            throw new WrongAnswer("Every component in the application must have a name. Component : " + e);
          if (e.getName().equals(String.format("EdgeLabel <%s -> %s>", v, u))) {
            foundEdgeLabel = true;
            var text = ((JLabel) e).getText();
            if (!text.equals(weight + ""))
              throw new WrongAnswer(String.format("EdgeLabel <%s -> %s> was expected " +
                  "to have weight %s but found %s", v, u, weight, text));
          }
        }

        String edgeMessage;

        if (value) {
          edgeMessage = "EdgeLabel (JLabel) with name \"EdgeLabel <%s -> %s>\" " +
              "must be placed in the graph panel after successful edge insertion";
        } else {
          edgeMessage = "EdgeLabel can be inserted in \"Add an Edge\" mode only.";
        }

        if (foundEdgeLabel != value)
          throw new WrongAnswer(String.format(edgeMessage, v, u));
      }

      private void checkEdge(String v, String u, boolean value) {
        boolean foundEdge = false;
        for (var e : getAllComponents(graph.target())) {
          if (e.getName() == null)
            throw new WrongAnswer("Every component in the application must have a name. Component : " + e);
          if (e.getName().equals(String.format("Edge <%s -> %s>", v, u))) {
            foundEdge = true;
          }
        }

        String edgeMessage;

        if (value) {
          edgeMessage = "Edge (JPanel) with name \"Edge <%s -> %s>\" " +
              "must be placed in the graph panel after successful insertion.";
        } else {
          edgeMessage = "Edges can be inserted in \"Add an Edge\" mode only.";
        }

        if (foundEdge != value)
          throw new WrongAnswer(String.format(edgeMessage, v, u));
      }

      private void tryToIncludeTwoArbitraryEdges(Map<String, Vertex> map, JPanel target) {
        var v = "A";
        var u = "D";
        var a = "C";
        var b = "F";

        addEdges(map, target, v, u, a, b);
        checkEdgeLabel(v, u, 1, false);
        checkEdgeLabel(a, b, 2, false);
        checkEdge(u, v, false);
        checkEdge(v, u, false);
        checkEdge(a, b, false);
        checkEdge(b, a, false);
      }

      private void addEdges(Map<String, Vertex> map, JPanel target, String v, String u, String a, String b) {
        JOptionPaneFixture dialog;
        dialog = TestingUtils.getOptionPaneFixture(getWindow().robot());

        dialog.textBox().setText(1 + "");
        dialog.okButton().click();

        var fixtureV = getVertexPanelFixture(map, target, v);
        var fixtureU = getVertexPanelFixture(map, target, u);
        fixtureV.click();
        fixtureU.click();

        dialog = TestingUtils.getOptionPaneFixture(getWindow().robot());
        dialog.textBox().setText(2 + "");
        dialog.okButton().click();

        var fixtureA = getVertexPanelFixture(map, target, a);
        var fixtureB = getVertexPanelFixture(map, target, b);
        fixtureA.click();
        fixtureB.click();
      }
    }
  learner_created: false
- name: test/TestingUtils.java
  visible: false
  text: |
    import org.assertj.swing.core.Robot;
    import org.assertj.swing.finder.JOptionPaneFinder;
    import org.assertj.swing.fixture.JOptionPaneFixture;
    import org.assertj.swing.fixture.JPanelFixture;
    import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
    import org.hyperskill.hstest.stage.SwingTest;
    import org.hyperskill.hstest.testcase.CheckResult;

    import javax.swing.*;
    import java.awt.*;
    import java.util.Arrays;
    import java.util.List;
    import java.util.NoSuchElementException;

    import static org.hyperskill.hstest.testcase.CheckResult.correct;
    import static org.hyperskill.hstest.testcase.CheckResult.wrong;

    public class TestingUtils {
      public static CheckResult assertComponentCount(JPanelFixture graph, int count) {
        var length = graph.target().getComponents().length;
        if (length != count)
          throw new WrongAnswer(String.format(
              "The graph panel should contain %d items, but %d items were found", count, length));
        return correct();
      }


      public static JOptionPaneFixture getOptionPaneFixture(Robot robot) {
        return JOptionPaneFinder
            .findOptionPane()
            .withTimeout(1000)
            .using(robot);
      }

      public static CheckResult addEdge(List<Edge> edges, JPanelFixture graph, Robot robot) {
        for (var e : edges) {
          new JPanelFixture(robot, (JPanel) getVertex(e.getFrom(), graph)).click();
          new JPanelFixture(robot, (JPanel) getVertex(e.getTo(), graph)).click();

          var dialog = getOptionPaneFixture(robot);
          dialog.textBox().setText(e.getWeight() + "");
          dialog.okButton().click();
        }

        var components = Arrays.stream(graph.target().getComponents())
            .filter((i) -> i.getName()
                .startsWith("Edge <"))
            .count();
        var noOfEdges = 2 * edges.size();
        if (components != noOfEdges)
          return wrong(String.format("%d edges was expected to be present, but found %d", noOfEdges, components));

        return correct();
      }

      public static Component getVertex(String id, JPanelFixture graph) {
        for (var v : SwingTest.getAllComponents(graph.target())) {
          if (v.getName() == null) {
            throw new WrongAnswer("Every component must have a name. Unnamed Component Found : " + v);
          }
          if (v.getName().equals("Vertex " + id))
            return v;
        }
        throw new NoSuchElementException();
      }
    }
  learner_created: false
feedback_link: https://hyperskill.org/learn/step/15630#comment
status: Solved
feedback:
  message: Well done! You've finished the project. Select a new project on <a href="https://hyperskill.org/projects">JetBrains
    Academy</a> to continue learning.
  time: Thu, 02 Jun 2022 23:01:03 UTC
record: 7
