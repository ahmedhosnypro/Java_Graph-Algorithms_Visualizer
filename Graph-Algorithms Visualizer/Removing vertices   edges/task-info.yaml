type: edu
custom_name: Removing vertices & edges
files:
- name: src/visualizer/ApplicationRunner.java
  visible: true
  text: |
    package visualizer;

    public class ApplicationRunner {
        public static void main(String[] args) {
            new MainFrame();
        }
    }
  learner_created: false
- name: src/visualizer/MainFrame.java
  visible: true
  text: |-
    package visualizer;

    import javax.swing.*;

    public class MainFrame extends JFrame {
        public MainFrame() {
            setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            setSize(300, 300);
            setVisible(true);
            setLayout(null);
        }
    }
  learner_created: false
- name: src/visualizer/DefaultMenuBar.java
  visible: true
  text: |
    package visualizer;

    import javax.swing.*;
    import java.awt.event.KeyEvent;

    public class DefaultMenuBar extends JMenuBar {
        private final MainFrame mainFrame;
        private final JMenu modeMenu = new JMenu("Mode");
        private final JMenuItem addVertex = new JMenuItem(Mode.ADD_VERTEX.getName());
        private final JMenuItem addEdge = new JMenuItem(Mode.ADD_EDGE.getName());
        private final JMenuItem none = new JMenuItem(Mode.NONE_MODE.getName());
        private final JMenuItem exit = new JMenuItem("Exit");

        DefaultMenuBar(MainFrame mainFrame) {
            mainFrame.setJMenuBar(this);
            this.mainFrame = mainFrame;
            initComponents();
        }

        void initComponents() {
            modeMenu.setMnemonic(KeyEvent.VK_Q);
            add(modeMenu);

            addVertex.setName("Add a Vertex");
            addEdge.setName("Add an Edge");
            none.setName("None");

            addVertex.addActionListener(e -> mainFrame.setMode(Mode.ADD_VERTEX));
            addEdge.addActionListener(e -> mainFrame.setMode(Mode.ADD_EDGE));
            none.addActionListener(e -> mainFrame.setMode(Mode.NONE_MODE));
            exit.addActionListener(e -> System.exit(0));

            modeMenu.add(addVertex);
            modeMenu.add(addEdge);
            modeMenu.add(none);
            modeMenu.addSeparator();
            modeMenu.add(exit);
        }
    }
  learner_created: true
- name: src/visualizer/UndirectedEdge.java
  visible: true
  text: |
    package visualizer;

    import javax.swing.*;
    import java.awt.*;

    public class UndirectedEdge extends JComponent {
        private Vertex[] nodes = new Vertex[2];
        private int weight;
        private JLabel weightLabel = new JLabel();

        public UndirectedEdge( Vertex fstNode, Vertex sndNode, int weight) {
            nodes[0] = fstNode;
            nodes[1] = sndNode;
            this.weight = weight;

            setName(String.format("Edge <%c -> %c>", fstNode.getId(), sndNode.getId()));

            weightLabel.setFont(new Font("Arial", Font.BOLD, 20));
            weightLabel.setForeground(Color.RED);
            weightLabel.setText(String.valueOf(weight));
            weightLabel.setName(String.format("EdgeLabel <%c -> %c>", fstNode.getId(), sndNode.getId()));
        }

        @Override
        public void paint(Graphics g) {
            super.paint(g);

            g.setColor(Color.WHITE);
            g.setFont(new Font("Arial", Font.BOLD, 5));
            g.drawLine(nodes[0].getX(), nodes[0].getY(), nodes[1].getX(), nodes[1].getY());
        }

        // getters

        Vertex[] getNodes() {
            return nodes;
        }

        int getWeight() {
            return weight;
        }

        JLabel getWeightLabel() {
            return weightLabel;
        }
    }
  learner_created: true
- name: src/visualizer/UndirectedEdgeCreator.java
  visible: true
  text: |
    package visualizer;

    import javax.swing.*;

    public class UndirectedEdgeCreator {
        private static Vertex fstNode = null;
        private static final String MESSAGE = "Enter Weight";
        private static final String TITLE = "Input";

        private UndirectedEdgeCreator() {
        }

        static void createUndirectedEdge(Vertex vertex) {
            if (fstNode == null) {
                fstNode = vertex;
            } else if (fstNode != vertex) {
                Integer weight = getWeight(vertex.getMainFrame().getGraph());
                if (weight == null) {
                    fstNode.getMainFrame().getGraph().whiteVertices();
                    fstNode = null;
                    return;
                }
                var undirectedEdges = vertex.getMainFrame().getGraph().getEdges();
                if (!isDuplicateEdge(undirectedEdges, vertex)) {

                    vertex.getMainFrame().getGraph()
                            .addNewEdge(new UndirectedEdge(fstNode, vertex, weight),
                                    new UndirectedEdge(vertex, fstNode, weight));
                    fstNode = null;
                }
            }
        }

        private static Integer getWeight(UndirectedGraph graph) {
            String input = JOptionPane.showInputDialog(graph, MESSAGE, TITLE, JOptionPane.QUESTION_MESSAGE);
            if (input == null) {
                return null;
            }
            if (isValidWeight(input)) {
                return Integer.parseInt(input);
            }
            return getWeight(graph);
        }


        private static boolean isValidWeight(String input) {
            try {
                Integer.parseInt(input);
                return true;
            } catch (IllegalArgumentException e) {
                return false;
            }
        }

        private static boolean isDuplicateEdge(java.util.Set<UndirectedEdge> edges, Vertex sndNode) {
            return edges.stream()
                    .anyMatch(edge -> edge.getNodes()[0] == fstNode && edge.getNodes()[1] == sndNode);
        }

        public static void reset() {
            fstNode = null;
        }
    }
  learner_created: true
- name: src/visualizer/Mode.java
  visible: true
  text: |
    package visualizer;

    public enum Mode {
        ADD_VERTEX("Add a Vertex"),
        ADD_EDGE("Add an Edge"),
        NONE_MODE("None");

        private final String name;

        Mode(String mode) {
            this.name = mode;
        }

        public String getName() {
            return name;
        }
    }
  learner_created: true
- name: src/visualizer/VertexCreator.java
  visible: true
  text: |
    package visualizer;

    import javax.swing.*;

    public class VertexCreator {
        private static final String MESSAGE = "Enter the Vertex Id (should be 1 char";
        private static final String TITLE = "Vertex";

        private VertexCreator() {
        }


        static Vertex createVertex(MainFrame mainFrame, int x, int y) {
            String input = JOptionPane.showInputDialog(mainFrame, MESSAGE, TITLE, JOptionPane.QUESTION_MESSAGE);
            if (input == null) {
                return null;
            }
            if (isValidId(input)) {
                return new Vertex(mainFrame, x, y, input.charAt(0));
            }
            return createVertex(mainFrame, x, y);
        }


        private static boolean isValidId(String input) {
            if (input.length() == 1) {
                return input.matches("[A-Za-z\\d]");
            }
            return false;
        }
    }
  learner_created: true
- name: src/visualizer/Vertex.java
  visible: true
  text: |
    package visualizer;

    import javax.swing.*;
    import java.awt.*;
    import java.awt.event.MouseAdapter;
    import java.awt.event.MouseEvent;
    import java.util.HashSet;
    import java.util.Set;

    public class Vertex extends JPanel {
        private static final int DIFF_X = 25;
        private static final int DIFF_Y = 25;
        private static final int SIZE = 50;

        private final MainFrame mainFrame;

        private final JLabel label = new JLabel();

        private final Set<Vertex> connectedVertices = new HashSet<>();

        private int centerX;
        private int centerY;
        private char id;
        private static final Color DEFAULT_COLOR = Color.WHITE;
        private Color color = DEFAULT_COLOR;


        // private final int diffX = 734;  // for corner vertices apply x = (i % 2) * diffX
        // private final int diffY = 511;   // for corner vertices apply y = (i / 2) * diffY


        public Vertex(MainFrame mainFrame, int x, int y, char id) {
            this.mainFrame = mainFrame;
            this.centerX = x - DIFF_X;
            this.centerY = y - DIFF_Y;
            this.id = id;

            initComponents();
            setActionEvents();
        }

        private void initComponents() {
            setName("Vertex " + id);
            setLayout(new GridBagLayout());
            setBounds(centerX, centerY, SIZE, SIZE);

            label.setName("VertexLabel " + id);
            label.setText(String.valueOf(id));
            label.setFont(new Font("SansSerif", Font.BOLD, 40));
            label.setForeground(Color.BLACK);
            add(label);
        }

        private void setActionEvents() {
            addMouseListener(new MouseAdapter() {
                @Override
                public void mouseClicked(MouseEvent e) {
                    super.mouseClicked(e);
                    switch (mainFrame.getMode()) {
                        case ADD_VERTEX, NONE_MODE -> highlight();
                        case ADD_EDGE -> createEdge();
                    }
                }
            });
        }

        @Override
        protected void paintComponent(Graphics g) {
            g.setColor(color);
            g.fillOval(0, 0, SIZE, SIZE);
        }

        private void createEdge() {
            highlight();
            UndirectedEdgeCreator.createUndirectedEdge(Vertex.this);
        }

        private void highlight() {
            mainFrame.getGraph().whiteVertices();
            color = Color.yellow;
            mainFrame.getGraph().repaint();
        }

        void connectVertex(Vertex vertex) {
            connectedVertices.add(vertex);
        }

        void disconnectVertex(Vertex vertex) {
            connectedVertices.removeIf(v -> v == vertex);
        }

        // setters
        public void setX(int centerX) {
            this.centerX = centerX;
        }

        public void setY(int centerY) {
            this.centerY = centerY;
        }

        public void setId(char id) {
            this.id = id;
        }

        void setLabel(String labelText) {
            label.setText(labelText);
        }

        public void resetColor() {
            this.color = DEFAULT_COLOR;
        }

        // getters
        char getId() {
            return id;
        }

        Set<Vertex> getConnectedVertices() {
            return connectedVertices;
        }

        public int getCenterX() {
            return centerX + DIFF_X;
        }

        public int getCenterY() {
            return centerY + DIFF_Y;
        }

        public MainFrame getMainFrame() {
            return mainFrame;
        }
    }
  learner_created: true
- name: src/visualizer/UndirectedGraph.java
  visible: true
  text: |-
    package visualizer;

    import javax.swing.*;
    import java.awt.*;
    import java.awt.event.MouseAdapter;
    import java.awt.event.MouseEvent;
    import java.util.HashSet;
    import java.util.Set;

    public class UndirectedGraph extends JPanel {
        private final Set<Vertex> vertices = new HashSet<>();
        private final Set<UndirectedEdge> edges = new HashSet<>();

        private final Set<JLabel> weightLabels = new HashSet<>();

        private final MainFrame mainFrame;

        public UndirectedGraph(MainFrame mainFrame, LayoutManager layout, String name) {
            this.mainFrame = mainFrame;
            setLayout(layout);
            setName(name);
            setForeground(Color.RED);
            setBackground(Color.BLACK);
            setBounds(0, 0, 800, 600);

            addMouseListener(new MouseAdapter() {
                @Override
                public void mouseClicked(MouseEvent e) {
                    super.mouseClicked(e);
                    switch (mainFrame.getMode()) {
                        case ADD_VERTEX -> createVertex(e);
                        case ADD_EDGE -> {
                            // To Do
                        }
                        case NONE_MODE -> whiteVertices();
                    }
                }
            });
        }


        @Override
        protected void paintComponent(Graphics g) {
            setupLabelPosition();
            super.paintComponent(g);
        }

        @Override
        protected void paintChildren(Graphics g) {

            Graphics2D g2 = (Graphics2D) g;
            g2.setStroke(new BasicStroke(3));
            g2.setColor(Color.WHITE);
            for (var edge : edges) {
                drawEdge(g2, edge);
            }

            super.paintChildren(g);
        }

        private void drawEdge(Graphics2D g2, UndirectedEdge edge) {
            var nodes = edge.getNodes();
            int x1 = nodes[0].getCenterX();
            int y1 = nodes[0].getCenterY();
            int x2 = nodes[1].getCenterX();
            int y2 = nodes[1].getCenterY();

            g2.drawLine(x1, y1, x2, y2);
        }

        private void setupLabelPosition() {
            for (var edge : edges) {
                var nodes = edge.getNodes();
                int x1 = nodes[0].getCenterX();
                int y1 = nodes[0].getCenterY();
                int x2 = nodes[1].getCenterX();
                int y2 = nodes[1].getCenterY();

                int centerX = Math.min(x1, x2) + Math.abs(x1 - x2) / 2;
                int centerY = Math.min(y1, y2) + Math.abs(y1 - y2) / 2;

                int dist = 25;
                int distSqr = dist * dist;
                if (x1 - x2 != 0) {
                    float slope = (float) (y1 - y2) / (x2 - x1);
                    double slopeSqr = slope * slope;
                    double diffX = Math.sqrt(distSqr / (1 + slopeSqr));
                    double diffY = Math.sqrt(distSqr - distSqr / (1 + slopeSqr));

                    centerX = (int) (centerX + diffX);
                    centerY = (int) (centerY + diffY);
                }
                edge.getWeightLabel().setBounds(centerX, centerY, 30, 30);
            }
        }

        private void createVertex(MouseEvent e) {
            whiteVertices();
            Vertex vertex = VertexCreator.createVertex(mainFrame, e.getX(), e.getY());
            if (vertex != null) {
                add(vertex);
                vertices.add(vertex);
                paintComponents(getGraphics());
                mainFrame.repaint();
            }
        }

        void whiteVertices() {
            vertices.forEach(Vertex::resetColor);
            mainFrame.repaint();
        }

        void addNewEdge(UndirectedEdge newEdge, UndirectedEdge stupidStageLogic) {
            if (!isDuplicateEdge(newEdge)) {
                edges.add(newEdge);
                add(newEdge);
                add(stupidStageLogic);

                weightLabels.add(newEdge.getWeightLabel());
                add(newEdge.getWeightLabel());

                whiteVertices();
                mainFrame.repaint();

            }
        }

        private boolean isDuplicateEdge(UndirectedEdge newEdge) {
            return edges.stream()
                    .anyMatch(e -> e.getNodes()[0] == newEdge.getNodes()[0] && e.getNodes()[1] == newEdge.getNodes()[1]);
        }

        // getters
        Set<UndirectedEdge> getEdges() {
            return edges;
        }
    }
  learner_created: true
- name: test/RemovingVerticesAndEdgesTests.java
  visible: false
  text: |
    import org.assertj.swing.exception.ComponentLookupException;
    import org.assertj.swing.exception.WaitTimedOutError;
    import org.assertj.swing.finder.JOptionPaneFinder;
    import org.assertj.swing.fixture.JLabelFixture;
    import org.assertj.swing.fixture.JMenuItemFixture;
    import org.assertj.swing.fixture.JOptionPaneFixture;
    import org.assertj.swing.fixture.JPanelFixture;
    import org.hyperskill.hstest.dynamic.DynamicTest;
    import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
    import org.hyperskill.hstest.stage.SwingTest;
    import org.hyperskill.hstest.testcase.CheckResult;
    import org.hyperskill.hstest.testing.swing.SwingComponent;
    import visualizer.MainFrame;

    import javax.swing.*;
    import java.awt.*;
    import java.util.ArrayList;
    import java.util.List;
    import java.util.Objects;
    import java.util.Optional;
    import java.util.regex.Pattern;

    import static org.assertj.core.api.Assertions.assertThat;
    import static org.hyperskill.hstest.testcase.CheckResult.correct;
    import static org.hyperskill.hstest.testcase.CheckResult.wrong;

    class Vertex {
        private final String id;
        private final Point point;

        Vertex(String id, Point point) {
            this.id = id;
            this.point = point;
        }

        public static Vertex of(String id) {
            return new Vertex(id, null);
        }

        public Point point() {
            return point;
        }

        public String id() {
            return id;
        }

        public String name() {
            return "Vertex " + id;
        }

        public String labelName() {
            return "VertexLabel " + id;
        }
    }

    class Edge {
        private final String from;
        private final String to;
        private final int weight;

        public Edge(String from, String to, int weight) {
            this.from = from;
            this.to = to;
            this.weight = weight;
        }

        public static Edge of(String from, String to) {
            return new Edge(from, to, 0);
        }

        public String from() {
            return from;
        }

        public String to() {
            return to;
        }

        public int weight() {
            return weight;
        }

        public String name() {
            return "Edge <" + from + " -> " + to + ">";
        }

        public String labelName() {
            return "EdgeLabel <" + from + " -> " + to + ">";
        }

        public Edge opposite() {
            return new Edge(this.to, this.from, this.weight);
        }
    }

    enum ComponentType {
        VERTEX("Vertex "),
        EDGE("Edge "),
        EDGE_LABEL("EdgeLabel "),
        VERTEX_LABEL("VertexLabel "),
        ANY("");

        private final String prefix;

        ComponentType(String prefix) {
            this.prefix = prefix;
        }

        public String prefix() {
            return prefix;
        }
    }

    @SuppressWarnings("unused")
    public class RemovingVerticesAndEdgesTests extends SwingTest {

        @SwingComponent(name = "Graph")
        private JPanelFixture graph;

        @SwingComponent(name = "Mode")
        private JLabelFixture modeText;

        @SwingComponent(name = "Add a Vertex")
        private JMenuItemFixture addAVertexMode;

        @SwingComponent(name = "Add an Edge")
        private JMenuItemFixture addAnEdgeMode;

        @SwingComponent(name = "Remove a Vertex")
        private JMenuItemFixture removeAVertexMode;

        @SwingComponent(name = "Remove an Edge")
        private JMenuItemFixture removeAnEdgeMode;

        @SwingComponent(name = "New")
        private JMenuItemFixture newMenuItem;

        @SwingComponent(name = "Exit")
        private JMenuItemFixture exitMenuItem;

        @SwingComponent(name = "None")
        private JMenuItemFixture noneMode;

        public RemovingVerticesAndEdgesTests() {
            super(new MainFrame());
        }

        @DynamicTest(order = 1, feedback = "Title should be \"Graph-Algorithms Visualizer\"")
        CheckResult isCorrectFrameTitle() {

            assertThat(frame.getTitle())
                .containsIgnoringCase("Graph-Algorithms Visualizer");

            return correct();
        }

        @DynamicTest(order = 2, feedback = "Size of Frame Should be - (800 x 600)")
        CheckResult isCorrectFrameDimension() {

            Dimension size = frame.getSize();

            assertThat(size.getWidth())
                .isEqualTo(800);
            assertThat(size.getHeight())
                .isEqualTo(600);

            return correct();
        }

        @DynamicTest(order = 3, feedback = "Initially graph panel should not contain anything.")
        CheckResult isEmptyGraph() {
            assertThat(count(ComponentType.ANY))
                .isEqualTo(0);
            return correct();
        }

        @DynamicTest(order = 4, feedback = "Initial Mode must be \"Add a Vertex\"")
        CheckResult isCorrectCurrentMode() {
            modeText.requireText(Pattern.compile(".*add a vertex.*", Pattern.CASE_INSENSITIVE));
            return correct();
        }


        @DynamicTest(order = 5, feedback = "Mode text should change after switching modes")
        CheckResult isModeSwitchFunctioning() {

            addAVertexMode.click();
            modeText.requireText(Pattern.compile(".*add a vertex.*", Pattern.CASE_INSENSITIVE));

            removeAVertexMode.click();
            modeText.requireText(Pattern.compile(".*remove a vertex.*", Pattern.CASE_INSENSITIVE));

            addAnEdgeMode.click();
            modeText.requireText(Pattern.compile(".*add an edge.*", Pattern.CASE_INSENSITIVE));

            removeAnEdgeMode.click();
            modeText.requireText(Pattern.compile(".*remove an edge.*", Pattern.CASE_INSENSITIVE));

            noneMode.click();
            modeText.requireText(Pattern.compile(".*none.*", Pattern.CASE_INSENSITIVE));

            return correct();
        }

        private final Vertex[] vertices = new Vertex[]{
            new Vertex("A", new Point(100, 200)),
            new Vertex("B", new Point(400, 300)),
            new Vertex("C", new Point(300, 400)),
            new Vertex("D", new Point(200, 100)),
            new Vertex("E", new Point(700, 200)),
            new Vertex("F", new Point(700, 100))
        };

        @DynamicTest(order = 6)
        CheckResult changeModeToAddAVertex() {
            addAVertexMode.click();
            return correct();
        }

        @DynamicTest(order = 7, feedback = "Could not insert vertex", data = "vertices")
        CheckResult insertVertex(Vertex vertex) {

            getWindow().robot().click(graph.target(), vertex.point());

            JOptionPaneFixture jOptionPaneFixture;
            try {

                jOptionPaneFixture = JOptionPaneFinder
                    .findOptionPane()
                    .withTimeout(200)
                    .using(getWindow().robot());

            } catch (WaitTimedOutError e) {
                return wrong("Timeout waiting for a dialog box to open");
            }

            try {

                jOptionPaneFixture.textBox();

            } catch (ComponentLookupException e) {
                return wrong("A text box was not found inside the dialog box");
            }

            try {

                jOptionPaneFixture.okButton();

            } catch (ComponentLookupException e) {
                return wrong("A ok button was not found inside the dialog box");
            }

            try {

                jOptionPaneFixture.cancelButton();

            } catch (ComponentLookupException e) {
                return wrong("A cancel button was not found inside the dialog box");
            }

            try {

                jOptionPaneFixture.requireTitle(Pattern.compile("vertex", Pattern.CASE_INSENSITIVE));

            } catch (Exception ignore) {
                return wrong("Dialog box title should contain \"Vertex\"");
            }


            try {

                jOptionPaneFixture
                    .textBox()
                    .setText(vertex.id());

                jOptionPaneFixture
                    .textBox()
                    .requireText(vertex.id());
            } catch (Exception e) {
                return wrong("Cannot write text '" + vertex.id() + "' in dialog box / Incorrect text after writing. Expected: '" + vertex.id() + "'");
            }

            JOptionPaneFinder
                .findOptionPane()
                .using(getWindow().robot())
                .okButton()
                .click();

            try {

                JOptionPaneFinder
                    .findOptionPane()
                    .withTimeout(200)
                    .using(getWindow().robot());

                return wrong("Dialog box did not disappear after clicking ok");
            } catch (WaitTimedOutError ignored) {
            }

            Optional<Component> vOp = getVertex(vertex.id());

            if (vOp.isEmpty()) {
                return wrong(vertex.name() + " was not created. It is not present in graph panel");
            }

            if (!(vOp.get() instanceof JPanel)) {
                throw new WrongAnswer("Each Vertex should be represented by a JPanel.");
            }

            JPanel v = (JPanel) vOp.get();

            if (v.getSize().getHeight() != 50 || v.getSize().getWidth() != 50) {
                Dimension expected = new Dimension(50, 50);
                Dimension got = v.getSize();
                throw new WrongAnswer("Incorrect Vertex Size. Expected: " + expected + ", Got: " + got);
            }

            Optional<Component> vl = getVertexLabel(vertex.id());

            if (vl.isEmpty()) {
                throw new WrongAnswer("Label of " + vertex.name() + " is not Present.");
            }

            if (!(vl.get() instanceof JLabel)) {
                throw new WrongAnswer("Each Vertex label must be represented by JLabel.");
            }

            JLabel vLabel = (JLabel) vl.get();

            if (!Objects.equals(vLabel.getParent().getName(), vertex.name())) {
                throw new WrongAnswer("Each Label of each vertex must be present inside it.");
            }

            if (!Objects.equals(vLabel.getText(), vertex.id())) {
                throw new WrongAnswer("Vertex Label Should Contain ID of Vertex");
            }

            Point got = v.getLocation();
            Point expected = new Point((int) (vertex.point().getX() - 25), (int) (vertex.point().getY() - 25));
            if (!expected.equals(got)) {
                throw new WrongAnswer("Incorrect Position. Expected: " + expected + ", Got: " + got);
            }

            return correct();
        }

        private final Edge[] edges = new Edge[]{
            new Edge("D", "B", 1),
            new Edge("A", "B", 1),
            new Edge("C", "A", 2),
            new Edge("A", "D", 3),
            new Edge("B", "C", 4),
            new Edge("C", "D", 6),
            new Edge("B", "F", 5),
            new Edge("C", "E", -1)
        };

        @DynamicTest(order = 8)
        CheckResult changeModeToAddAnEdge() {
            addAnEdgeMode.click();
            return correct();
        }

        @DynamicTest(order = 9, data = "edges", feedback = "Could not insert edges")
        CheckResult insertEdge(Edge edge) {


            getWindow().robot().click(getVertex(edge.from()).orElseThrow());
            getWindow().robot().click(getVertex(edge.to()).orElseThrow());

            JOptionPaneFixture jOptionPaneFixture;

            try {
                jOptionPaneFixture = JOptionPaneFinder
                    .findOptionPane()
                    .withTimeout(1000)
                    .using(getWindow().robot());
            } catch (WaitTimedOutError e) {
                return wrong("Clicking on two vertices in the \"Add an Edge\" mode; a new window must pop up prompting for edge weight");
            }

            try {
                jOptionPaneFixture.okButton();
            } catch (ComponentLookupException e) {
                return wrong("A ok button was not found in edge weight prompting input box.");
            }

            try {
                jOptionPaneFixture.cancelButton();
            } catch (ComponentLookupException e) {
                return wrong("A cancel button was not found in edge weight prompting input box.");
            }

            try {
                jOptionPaneFixture.textBox();
            } catch (ComponentLookupException e) {
                return wrong("A text box was not found in edge weight prompting input box.");
            }

            try {
                jOptionPaneFixture
                    .textBox()
                    .setText(edge.weight() + "");

                jOptionPaneFixture
                    .textBox()
                    .requireText(edge.weight() + "");
            } catch (Exception e) {
                return wrong("Could not enter text in the edge weight prompting dialog box.");
            }

            jOptionPaneFixture
                .okButton()
                .click();

            try {
                JOptionPaneFinder
                    .findOptionPane()
                    .withTimeout(1000)
                    .using(getWindow().robot());

                return wrong("Dialog box must close after clicking on ok button.");
            } catch (WaitTimedOutError ignored) {
            }

            Component aTob = getEdge(edge.from(), edge.to()).orElseThrow(() -> new WrongAnswer("\"" + edge.labelName() + "\" was not found!"));

            Component bToa = getEdge(edge.to(), edge.from()).orElseThrow(() -> new WrongAnswer("\"" + edge.opposite().labelName() + "\" was not found!"));

            Component label = getEdgeLabel(edge.from(), edge.to()).orElseThrow(() -> new WrongAnswer("Edge Label which should contain the edge weight was not found in graph."));

            if (!(aTob instanceof JComponent) || !(bToa instanceof JComponent))
                throw new WrongAnswer("Edge must be represented by JComponent");

            if (!(label instanceof JLabel))
                throw new WrongAnswer("EdgeLabel must be represented by JLabel");

            if (!Objects.equals(graph.target(), label.getParent()))
                throw new WrongAnswer("Parent of each edge label is the graph itself not the edge.");


            try {
                assertThat(((JLabel) label).getText())
                    .containsIgnoringCase(edge.weight() + "");
            } catch (Exception e) {
                return wrong("Edge Label should hold the weight of the respective edge");
            }

            return correct();
        }

        private final String[] incorrectWeights = new String[]{"", " ", "  ", "A", "BC", "!", "Cancel"};

        @DynamicTest(order = 10, data = "incorrectWeights")
        CheckResult incorrectEdgeWeights(String weight) {

            getWindow().robot().click(getVertex("D").orElseThrow());
            getWindow().robot().click(getVertex("F").orElseThrow());

            try {
                JOptionPaneFixture jOptionPaneFixture = JOptionPaneFinder
                    .findOptionPane()
                    .withTimeout(1000)
                    .using(getWindow().robot());
                jOptionPaneFixture.textBox().setText(weight);
                if (!weight.equals("Cancel"))
                    jOptionPaneFixture.okButton().click();
                else
                    jOptionPaneFixture.cancelButton().click();

                if (!weight.equals("Cancel"))
                    JOptionPaneFinder
                        .findOptionPane()
                        .withTimeout(1000)
                        .using(getWindow().robot());

                return correct();
            } catch (WaitTimedOutError e) {
                return wrong("Dialog box should appear again and again if invalid input is given");
            }
        }

        @DynamicTest(order = 11)
        CheckResult vertexInsertionInIncorrectMode() {

            changeModeToAddAnEdge();
            graph.click();

            try {
                JOptionPaneFinder
                    .findOptionPane()
                    .withTimeout(1000)
                    .using(getWindow().robot());
                return wrong("Vertex should not be inserted in other modes");
            } catch (WaitTimedOutError e) {
                return correct();
            } catch (Exception e) {
                return wrong("Vertex should not be inserted in other modes");
            }
        }

        @DynamicTest(order = 12)
        CheckResult edgeInsertionInIncorrectMode() {

            changeModeToAddAVertex();
            getWindow().robot().click(getVertex("D").orElseThrow());
            getWindow().robot().click(getVertex("F").orElseThrow());

            try {
                JOptionPaneFinder
                    .findOptionPane()
                    .withTimeout(1000)
                    .using(getWindow().robot());
                return wrong("Edge should not be inserted in other modes");
            } catch (WaitTimedOutError e) {
                return correct();
            } catch (Exception e) {
                return wrong("Edge should not be inserted in other modes");
            }
        }

        @DynamicTest(order = 13)
        CheckResult checkVertexCount() {
            int got = count(ComponentType.VERTEX);
            int expected = vertices.length;
            if (expected != got)
                return wrong("Incorrect Vertex Count. Expected = " + expected + ", Got = " + got);
            return correct();
        }

        @DynamicTest(order = 14)
        CheckResult checkEdgeCount() {
            int got = count(ComponentType.EDGE);
            int expected = edges.length * 2;
            if (expected != got)
                return wrong("Incorrect Edge Count. Expected = " + expected + ", Got = " + got);
            return correct();
        }

        @DynamicTest(order = 15)
        CheckResult checkVertexLabelCount() {
            int got = count(ComponentType.VERTEX_LABEL);
            int expected = vertices.length;
            if (expected != got)
                return wrong("Incorrect Vertex Label (id) Count. Expected = " + expected + ", Got = " + got);
            return correct();
        }

        @DynamicTest(order = 16)
        CheckResult checkEdgeLabelCount() {
            int got = count(ComponentType.EDGE_LABEL);
            int expected = edges.length;
            if (expected != got)
                return wrong("Incorrect Edge Label Count. Expected = " + expected + ", Got = " + got);
            return correct();
        }

        @DynamicTest(order = 17)
        CheckResult switchToRemoveAnEdgeMode() {
            removeAnEdgeMode.click();
            return correct();
        }

        private final String[][] toBeRemovedEdges = new String[][]{
            new String[]{"B", "F"},
            new String[]{"C", "E"}
        };

        @DynamicTest(order = 18, data = "toBeRemovedEdges", feedback = "Could not remove Edge")
        CheckResult removeEdge(String from, String to) {

            getWindow().robot().click(getEdge(from, to).orElseThrow());

            if (getEdge(from, to).isPresent()) {
                throw new WrongAnswer(Edge.of(from, to).name() + " is present in graph even after removing");
            }

            if (getEdge(to, from).isPresent()) {
                throw new WrongAnswer(Edge.of(to, from).name() + " is present in graph even after removing");
            }

            if (getEdgeLabel(from, to).isPresent()) {
                throw new WrongAnswer(Edge.of(from, to).labelName() + " is present in graph even after removing");
            }

            return correct();
        }

        @DynamicTest(order = 19)
        CheckResult switchToRemoveAVertexMode() {
            removeAVertexMode.click();
            return correct();
        }

        private final String[] toBeRemovedVertices = new String[]{"F", "E", "B", "C"};

        @DynamicTest(order = 20, data = "toBeRemovedVertices", feedback = "Could not remove Vertex")
        CheckResult removeVertex(String id) {

            getWindow().robot().click(getVertex(id).orElseThrow());

            if (getVertex(id).isPresent()) {
                throw new WrongAnswer(Vertex.of(id).name() + " is present in graph even after removing");
            }

            if (getVertexLabel(id).isPresent()) {
                throw new WrongAnswer(Vertex.of(id).labelName() + " is present in graph even after removing");
            }

            int adjEdgesCount = getInOrOutEdgesCount(id);
            if (adjEdgesCount != 0) {
                throw new WrongAnswer("All inward and outward edges of the vertex should be removed after removing the vertex itself. Found = " + adjEdgesCount);
            }

            return correct();
        }

        @DynamicTest(order = 21)
        CheckResult removeVertexInOtherModes() {
            for (var mode : List.of(addAVertexMode, addAnEdgeMode, removeAnEdgeMode, noneMode)) {
                mode.click();
                try {
                    removeVertex("A");
                    return wrong("Removed Vertex in wrong mode : " + mode.target().getName());
                } catch (Throwable ignored) {}
            }
            return correct();
        }

        @DynamicTest(order = 22)
        CheckResult removeEdgeInOtherModes() {
            for (var mode : List.of(addAVertexMode, addAnEdgeMode, removeAVertexMode, noneMode)) {
                mode.click();
                try {
                    removeEdge("A", "D");
                    return wrong("Removed Edge in wrong mode : " + mode.target().getName());
                } catch (Throwable ignored) {}
            }
            return correct();
        }

        @DynamicTest(order = 23)
        CheckResult checkNewMenuItem() {
            newMenuItem.click();

            if (count(ComponentType.ANY) != 0) {
                return wrong("Clicking on \"New\" menu should clear out the entire graph.");
            }

            return correct();
        }

        private int getInOrOutEdgesCount(String id) {
            List<Component> components = new ArrayList<>();
            for (var c : getAllComponents(graph.target())) {
                if (c.getName() != null && (
                    c.getName().startsWith("Edge <" + id + " -> ") ||
                        c.getName().startsWith("EdgeLabel <" + id + " -> ") ||
                        c.getName().endsWith(" -> " + id + ">")
                )) {
                    components.add(c);
                }
            }
            return components.size();
        }

        private int count(ComponentType type) {
            return (int) getAllComponents(graph.target())
                .stream()
                .filter(it -> it.getName() != null && it.getName().startsWith(type.prefix()))
                .count();
        }

        private Optional<Component> getVertexLabel(String id) {
            String name = Vertex.of(id).labelName();

            return getAllComponents(graph.target())
                .stream()
                .filter(it -> Objects.equals(it.getName(), name))
                .findFirst();

        }

        private Optional<Component> getEdgeLabel(String from, String to) {
            String name = Edge.of(from, to).labelName();

            return getAllComponents(graph.target())
                .stream()
                .filter(it -> Objects.equals(it.getName(), name))
                .findFirst();

        }

        private Optional<Component> getEdge(String from, String to) {
            String name = Edge.of(from, to).name();

            return getAllComponents(graph.target())
                .stream()
                .filter(it -> Objects.equals(it.getName(), name))
                .findFirst();
        }

        private Optional<Component> getVertex(String id) {
            String name = Vertex.of(id).name();

            return getAllComponents(graph.target())
                .stream()
                .filter(it -> Objects.equals(name, it.getName()))
                .findFirst();
        }
    }
  learner_created: false
feedback_link: https://hyperskill.org/learn/step/15627#comment
status: Solved
feedback:
  message: Congratulations!
  time: Sat, 28 May 2022 14:34:16 UTC
record: 4
