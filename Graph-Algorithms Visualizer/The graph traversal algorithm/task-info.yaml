type: edu
files:
- name: src/visualizer/ApplicationRunner.java
  visible: true
  text: |
    package visualizer;

    public class ApplicationRunner {
        public static void main(String[] args) {
            new MainFrame();
        }
    }
  learner_created: false
- name: src/visualizer/MainFrame.java
  visible: true
  text: |-
    package visualizer;

    import javax.swing.*;

    public class MainFrame extends JFrame {
        public MainFrame() {
            setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            setSize(300, 300);
            setVisible(true);
            setLayout(null);
        }
    }
  learner_created: false
- name: src/visualizer/DefaultMenuBar.java
  visible: true
  text: |
    package visualizer;

    import javax.swing.*;
    import java.awt.event.KeyEvent;

    public class DefaultMenuBar extends JMenuBar {
        private final MainFrame mainFrame;
        private final JMenu fileMenu = new JMenu("File");
        private final JMenu modeMenu = new JMenu("Mode");
        private final JMenuItem addVertex = new JMenuItem(Mode.ADD_VERTEX.getName());
        private final JMenuItem addEdge = new JMenuItem(Mode.ADD_EDGE.getName());
        private final JMenuItem removeVertex = new JMenuItem(Mode.REMOVE_VERTEX.getName());
        private final JMenuItem removeEdge = new JMenuItem(Mode.REMOVE_EDGE.getName());
        private final JMenuItem newMenuItem = new JMenuItem("New");
        private final JMenuItem noneModeMenuItem = new JMenuItem(Mode.NONE_MODE.getName());
        private final JMenuItem exit = new JMenuItem("Exit");

        DefaultMenuBar(MainFrame mainFrame) {
            mainFrame.setJMenuBar(this);
            this.mainFrame = mainFrame;
            initComponents();
        }

        void initComponents() {
            fileMenu.setName("File");
            add(fileMenu);

            newMenuItem.setName("New");
            newMenuItem.addActionListener(e -> mainFrame.getGraph().reset());

            exit.setName("Exit");
            exit.addActionListener(e -> System.exit(0));

            fileMenu.add(newMenuItem);
            fileMenu.addSeparator();
            fileMenu.add(exit);

            modeMenu.setName("Mode");
            modeMenu.setMnemonic(KeyEvent.VK_Q);
            add(modeMenu);


            addVertex.setName("Add a Vertex");
            addEdge.setName("Add an Edge");
            removeVertex.setName("Remove a Vertex");
            removeEdge.setName("Remove an Edge");
            noneModeMenuItem.setName("None");

            addVertex.addActionListener(e -> mainFrame.setMode(Mode.ADD_VERTEX));
            addEdge.addActionListener(e -> mainFrame.setMode(Mode.ADD_EDGE));
            removeVertex.addActionListener(e -> mainFrame.setMode(Mode.REMOVE_VERTEX));
            removeEdge.addActionListener(e -> mainFrame.setMode(Mode.REMOVE_EDGE));
            noneModeMenuItem.addActionListener(e -> mainFrame.setMode(Mode.NONE_MODE));

            modeMenu.add(addVertex);
            modeMenu.add(addEdge);
            modeMenu.add(removeVertex);
            modeMenu.add(removeEdge);
            modeMenu.add(noneModeMenuItem);

        }
    }
  learner_created: true
- name: src/visualizer/UndirectedEdge.java
  visible: true
  text: |
    package visualizer;

    import javax.swing.*;
    import java.awt.*;
    import java.awt.event.MouseAdapter;
    import java.awt.event.MouseEvent;

    public class UndirectedEdge extends JComponent {
        private Vertex[] nodes = new Vertex[2];
        private int weight;
        private JLabel weightLabel = new JLabel();
        private final UndirectedGraph graph;

        public UndirectedEdge(Vertex fstNode, Vertex sndNode, int weight, UndirectedGraph graph) {
            this.graph = graph;
            nodes[0] = fstNode;
            nodes[1] = sndNode;
            this.weight = weight;

            setName(String.format("Edge <%c -> %c>", fstNode.getId(), sndNode.getId()));

            weightLabel.setFont(new Font("Arial", Font.BOLD, 20));
            weightLabel.setForeground(Color.RED);
            weightLabel.setText(String.valueOf(weight));
            weightLabel.setName(String.format("EdgeLabel <%c -> %c>", fstNode.getId(), sndNode.getId()));

            setBackground(Color.WHITE);
            addEventListeners();
        }

        void addEventListeners() {
            addMouseListener(new MouseAdapter() {
                @Override
                public void mouseClicked(MouseEvent e) {
                    super.mouseClicked(e);
                    if (graph.mainFrame.getMode() == Mode.REMOVE_EDGE) {
                        graph.removeEdge(UndirectedEdge.this);
                    }
                }
            });
        }

        // getters

        Vertex[] getNodes() {
            return nodes;
        }

        int getWeight() {
            return weight;
        }

        JLabel getWeightLabel() {
            return weightLabel;
        }
    }
  learner_created: true
- name: src/visualizer/UndirectedEdgeCreator.java
  visible: true
  text: |
    package visualizer;

    import javax.swing.*;

    public class UndirectedEdgeCreator {
        private static Vertex fstNode = null;
        private static final String MESSAGE = "Enter Weight";
        private static final String TITLE = "Input";

        private UndirectedEdgeCreator() {
        }

        static void createUndirectedEdge(Vertex vertex) {
            if (fstNode == null) {
                fstNode = vertex;
            } else if (fstNode != vertex) {
                Integer weight = getWeight(vertex.getMainFrame().getGraph());
                if (weight == null) {
                    fstNode.getMainFrame().getGraph().whiteVertices();
                    fstNode = null;
                    return;
                }
                var undirectedEdges = vertex.getMainFrame().getGraph().getEdges();
                if (!isDuplicateEdge(undirectedEdges, vertex)) {

                    vertex.getMainFrame().getGraph()
                            .addNewEdge(new UndirectedEdge(fstNode, vertex, weight, vertex.getMainFrame().getGraph()),
                                    new UndirectedEdge(vertex, fstNode, weight, vertex.getMainFrame().getGraph()));
                    fstNode = null;
                }
            }
        }

        private static Integer getWeight(UndirectedGraph graph) {
            String input = JOptionPane.showInputDialog(graph, MESSAGE, TITLE, JOptionPane.QUESTION_MESSAGE);
            if (input == null) {
                return null;
            }
            if (isValidWeight(input)) {
                return Integer.parseInt(input);
            }
            return getWeight(graph);
        }


        private static boolean isValidWeight(String input) {
            try {
                Integer.parseInt(input);
                return true;
            } catch (IllegalArgumentException e) {
                return false;
            }
        }

        private static boolean isDuplicateEdge(java.util.Set<UndirectedEdge> edges, Vertex sndNode) {
            return edges.stream()
                    .anyMatch(edge -> edge.getNodes()[0] == fstNode && edge.getNodes()[1] == sndNode);
        }

        public static void reset() {
            fstNode = null;
        }
    }
  learner_created: true
- name: src/visualizer/Mode.java
  visible: true
  text: |
    package visualizer;

    public enum Mode {
        ADD_VERTEX("Add a Vertex"),
        ADD_EDGE("Add an Edge"),
        REMOVE_VERTEX("Remove a Vertex"),
        REMOVE_EDGE("Remove an Edge"),
        NONE_MODE("None");

        private final String name;

        Mode(String mode) {
            this.name = mode;
        }

        public String getName() {
            return name;
        }
    }
  learner_created: true
- name: src/visualizer/VertexCreator.java
  visible: true
  text: |
    package visualizer;

    import javax.swing.*;

    public class VertexCreator {
        private static final String MESSAGE = "Enter the Vertex Id (should be 1 char";
        private static final String TITLE = "Vertex";

        private VertexCreator() {
        }


        static Vertex createVertex(MainFrame mainFrame, int x, int y) {
            String input = JOptionPane.showInputDialog(mainFrame, MESSAGE, TITLE, JOptionPane.QUESTION_MESSAGE);
            if (input == null) {
                return null;
            }
            if (isValidId(input)) {
                return new Vertex(mainFrame, x, y, input.charAt(0));
            }
            return createVertex(mainFrame, x, y);
        }


        private static boolean isValidId(String input) {
            if (input.length() == 1) {
                return input.matches("[A-Za-z\\d]");
            }
            return false;
        }
    }
  learner_created: true
- name: src/visualizer/Vertex.java
  visible: true
  text: |
    package visualizer;

    import javax.swing.*;
    import java.awt.*;
    import java.awt.event.MouseAdapter;
    import java.awt.event.MouseEvent;
    import java.util.HashSet;
    import java.util.Set;

    public class Vertex extends JPanel {
        private static final int DIFF_X = 25;
        private static final int DIFF_Y = 25;
        private static final int SIZE = 50;

        private final MainFrame mainFrame;

        private final JLabel label = new JLabel();

        private final Set<Vertex> connectedVertices = new HashSet<>();

        private int centerX;
        private int centerY;
        private char id;
        private static final Color DEFAULT_COLOR = Color.WHITE;
        private Color color = DEFAULT_COLOR;


        // private final int diffX = 734;  // for corner vertices apply x = (i % 2) * diffX
        // private final int diffY = 511;   // for corner vertices apply y = (i / 2) * diffY


        public Vertex(MainFrame mainFrame, int x, int y, char id) {
            this.mainFrame = mainFrame;
            this.centerX = x - DIFF_X;
            this.centerY = y - DIFF_Y;
            this.id = id;

            initComponents();
            setActionEvents();
        }

        private void initComponents() {
            setName("Vertex " + id);
            setLayout(new GridBagLayout());
            setBounds(centerX, centerY, SIZE, SIZE);

            label.setName("VertexLabel " + id);
            label.setText(String.valueOf(id));
            label.setFont(new Font("SansSerif", Font.BOLD, 40));
            label.setForeground(Color.BLACK);
            add(label);
        }

        private void setActionEvents() {
            addMouseListener(new MouseAdapter() {
                @Override
                public void mouseClicked(MouseEvent e) {
                    super.mouseClicked(e);
                    switch (mainFrame.getMode()) {
                        case ADD_VERTEX, NONE_MODE, REMOVE_EDGE -> highlight();
                        case ADD_EDGE -> createEdge();
                        case REMOVE_VERTEX -> removeVertex();
                    }
                }
            });
        }

        @Override
        protected void paintComponent(Graphics g) {
            g.setColor(color);
            g.fillOval(0, 0, SIZE, SIZE);
        }

        private void createEdge() {
            highlight();
            UndirectedEdgeCreator.createUndirectedEdge(Vertex.this);
        }

        private void highlight() {
            mainFrame.getGraph().whiteVertices();
            color = Color.yellow;
            mainFrame.getGraph().repaint();
        }

        private void removeVertex() {
            mainFrame.getGraph().removeVertex(this);
        }

        void connectVertex(Vertex vertex) {
            connectedVertices.add(vertex);
        }

        void disconnectVertex(Vertex vertex) {
            connectedVertices.removeIf(v -> v == vertex);
        }

        // setters
        public void setX(int centerX) {
            this.centerX = centerX;
        }

        public void setY(int centerY) {
            this.centerY = centerY;
        }

        public void setId(char id) {
            this.id = id;
        }

        void setLabel(String labelText) {
            label.setText(labelText);
        }

        public void resetColor() {
            this.color = DEFAULT_COLOR;
        }

        // getters
        char getId() {
            return id;
        }

        Set<Vertex> getConnectedVertices() {
            return connectedVertices;
        }

        public int getCenterX() {
            return centerX + DIFF_X;
        }

        public int getCenterY() {
            return centerY + DIFF_Y;
        }

        public MainFrame getMainFrame() {
            return mainFrame;
        }
    }
  learner_created: true
- name: src/visualizer/UndirectedGraph.java
  visible: true
  text: |-
    package visualizer;

    import javax.swing.*;
    import java.awt.*;
    import java.awt.event.MouseAdapter;
    import java.awt.event.MouseEvent;
    import java.util.HashSet;
    import java.util.Set;

    public class UndirectedGraph extends JPanel {
        private final Set<Vertex> vertices = new HashSet<>();
        private final Set<UndirectedEdge> edges = new HashSet<>();

        private final Set<JLabel> weightLabels = new HashSet<>();

        final MainFrame mainFrame;

        public UndirectedGraph(MainFrame mainFrame, LayoutManager layout, String name) {
            this.mainFrame = mainFrame;
            setLayout(layout);
            setName(name);
            setForeground(Color.RED);
            setBackground(Color.BLACK);
            setBounds(0, 0, 800, 600);

            addMouseListener(new MouseAdapter() {
                @Override
                public void mouseClicked(MouseEvent e) {
                    super.mouseClicked(e);
                    switch (mainFrame.getMode()) {
                        case ADD_VERTEX -> createVertex(e);
                        case ADD_EDGE -> {
                            // To Do
                        }
                        case NONE_MODE -> whiteVertices();
                    }
                }
            });
        }

        protected void paintChildren(Graphics g) {

            Graphics2D g2 = (Graphics2D) g;
            g2.setStroke(new BasicStroke(3));
            g2.setColor(Color.WHITE);
            for (var edge : edges) {
                drawEdge(g2, edge);
            }

            super.paintChildren(g);
        }

        private void setupLabelPosition(UndirectedEdge edge) {
            var nodes = edge.getNodes();
            int x1 = nodes[0].getCenterX();
            int y1 = nodes[0].getCenterY();
            int x2 = nodes[1].getCenterX();
            int y2 = nodes[1].getCenterY();

            int centerX = Math.min(x1, x2) + Math.abs(x1 - x2) / 2;
            int centerY = Math.min(y1, y2) + Math.abs(y1 - y2) / 2;

            int dist = 25;
            int distSqr = dist * dist;
            if (x1 - x2 != 0) {
                float slope = (float) (y1 - y2) / (x2 - x1);
                double slopeSqr = slope * slope;
                double diffX = Math.sqrt(distSqr / (1 + slopeSqr));
                double diffY = Math.sqrt(distSqr - distSqr / (1 + slopeSqr));

                centerX = (int) (centerX + diffX);
                centerY = (int) (centerY + diffY);
            }
            edge.getWeightLabel().setBounds(centerX, centerY, 30, 30);
        }

        private void createVertex(MouseEvent e) {
            whiteVertices();
            Vertex vertex = VertexCreator.createVertex(mainFrame, e.getX(), e.getY());
            if (vertex != null) {
                add(vertex);
                vertices.add(vertex);
                paintComponents(getGraphics());
                mainFrame.repaint();
            }
        }

        void whiteVertices() {
            vertices.forEach(Vertex::resetColor);
            mainFrame.repaint();
        }

        private void drawEdge(Graphics2D g2, UndirectedEdge edge) {
            var nodes = edge.getNodes();
            int x1 = nodes[0].getCenterX();
            int y1 = nodes[0].getCenterY();
            int x2 = nodes[1].getCenterX();
            int y2 = nodes[1].getCenterY();

            g2.drawLine(x1, y1, x2, y2);
        }

        void addNewEdge(UndirectedEdge newEdge, UndirectedEdge stupidStageLogic) {
            if (!isDuplicateEdge(newEdge)) {
                edges.add(newEdge);
                add(newEdge);


                int x1 = newEdge.getNodes()[0].getCenterX();
                int y1 = newEdge.getNodes()[0].getCenterY();
                int x2 = newEdge.getNodes()[1].getCenterX();
                int y2 = newEdge.getNodes()[1].getCenterY();
                int centerX = Math.min(x1, x2) + Math.abs(x1 - x2) / 2;
                int centerY = Math.min(y1, y2) + Math.abs(y1 - y2) / 2;
                newEdge.setBounds(centerX-3, centerY-3, 6, 6);
                stupidStageLogic.setBounds(centerX, centerY, 6, 6);

                edges.add(stupidStageLogic);
                add(stupidStageLogic);

                setupLabelPosition(newEdge);
                weightLabels.add(newEdge.getWeightLabel());
                add(newEdge.getWeightLabel());

                whiteVertices();

                mainFrame.repaint();
            }
        }

        void removeEdge(UndirectedEdge edge) {
            remove(edge);
            edges.remove(edge);
            remove(edge.getWeightLabel());
            var oppositeEdge = edges
                    .stream()
                    .filter(it -> it.getNodes()[0] == edge.getNodes()[1] && it.getNodes()[1] == edge.getNodes()[0])
                    .findFirst();
            oppositeEdge.ifPresent(e -> remove(e.getWeightLabel()));
            oppositeEdge.ifPresent(this::remove);
            getWeightLabels().remove(edge.getWeightLabel());
            edge.getNodes()[0].disconnectVertex(edge.getNodes()[1]);
            edge.getNodes()[1].disconnectVertex(edge.getNodes()[0]);

            mainFrame.repaint();
        }

        void removeVertex(Vertex vertex) {
            remove(vertex);
            vertices.remove(vertex);
            edges.stream().filter(e -> e.getNodes()[0] == vertex || e.getNodes()[1] == vertex).forEach(this::removeEdge);
            edges.removeIf(e -> e.getNodes()[0] == vertex || e.getNodes()[1] == vertex);
            mainFrame.repaint();
        }

        void reset() {
            for (var vertex : vertices) {
                remove(vertex);
            }
            vertices.clear();

            for (var edge : edges) {
                remove(edge);
            }
            edges.clear();

            for (var label : weightLabels) {
                remove(label);
            }
            weightLabels.clear();

            mainFrame.setMode(Mode.ADD_VERTEX);

            mainFrame.repaint();
        }


        private boolean isDuplicateEdge(UndirectedEdge newEdge) {
            return edges.stream()
                    .anyMatch(e -> e.getNodes()[0] == newEdge.getNodes()[0] && e.getNodes()[1] == newEdge.getNodes()[1]);
        }

        // getters
        Set<UndirectedEdge> getEdges() {
            return edges;
        }

        public Set<JLabel> getWeightLabels() {
            return weightLabels;
        }
    }
  learner_created: true
- name: test/GraphTraversalAlgorithmTests.java
  visible: false
  text: |
    import org.assertj.swing.exception.ComponentLookupException;
    import org.assertj.swing.exception.WaitTimedOutError;
    import org.assertj.swing.finder.JOptionPaneFinder;
    import org.assertj.swing.fixture.JLabelFixture;
    import org.assertj.swing.fixture.JMenuItemFixture;
    import org.assertj.swing.fixture.JOptionPaneFixture;
    import org.assertj.swing.fixture.JPanelFixture;
    import org.hyperskill.hstest.common.Utils;
    import org.hyperskill.hstest.dynamic.DynamicTest;
    import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
    import org.hyperskill.hstest.stage.SwingTest;
    import org.hyperskill.hstest.testcase.CheckResult;
    import org.hyperskill.hstest.testing.swing.SwingComponent;
    import visualizer.MainFrame;

    import javax.swing.*;
    import java.awt.*;
    import java.util.Objects;
    import java.util.Optional;
    import java.util.regex.Pattern;

    import static org.assertj.core.api.Assertions.assertThat;
    import static org.hyperskill.hstest.testcase.CheckResult.correct;

    class Vertex {
        private final String id;
        private final Point point;

        Vertex(String id, Point point) {
            this.id = id;
            this.point = point;
        }

        public static Vertex of(String id) {
            return new Vertex(id, null);
        }

        public Point point() {
            return point;
        }

        public String id() {
            return id;
        }

        public String name() {
            return "Vertex " + id;
        }

        public String labelName() {
            return "VertexLabel " + id;
        }
    }

    class Edge {
        private final String from;
        private final String to;
        private final int weight;

        public Edge(String from, String to, int weight) {
            this.from = from;
            this.to = to;
            this.weight = weight;
        }

        public static Edge of(String from, String to) {
            return new Edge(from, to, 0);
        }

        public String from() {
            return from;
        }

        public String to() {
            return to;
        }

        public int weight() {
            return weight;
        }

        public String name() {
            return "Edge <" + from + " -> " + to + ">";
        }

        public String labelName() {
            return "EdgeLabel <" + from + " -> " + to + ">";
        }

        public Edge opposite() {
            return new Edge(this.to, this.from, this.weight);
        }
    }

    enum ComponentType {
        VERTEX("Vertex "),
        EDGE("Edge "),
        EDGE_LABEL("EdgeLabel "),
        VERTEX_LABEL("VertexLabel "),
        ANY("");

        private final String prefix;

        ComponentType(String prefix) {
            this.prefix = prefix;
        }

        public String prefix() {
            return prefix;
        }
    }

    @SuppressWarnings("unused")
    public class GraphTraversalAlgorithmTests extends SwingTest {

        @SwingComponent(name = "Graph")
        private JPanelFixture graph;

        @SwingComponent(name = "Mode")
        private JLabelFixture modeText;

        @SwingComponent(name = "Add a Vertex")
        private JMenuItemFixture addAVertexMode;

        @SwingComponent(name = "Add an Edge")
        private JMenuItemFixture addAnEdgeMode;

        @SwingComponent(name = "Remove a Vertex")
        private JMenuItemFixture removeAVertexMode;

        @SwingComponent(name = "Remove an Edge")
        private JMenuItemFixture removeAnEdgeMode;

        @SwingComponent(name = "New")
        private JMenuItemFixture newMenuItem;

        @SwingComponent(name = "Exit")
        private JMenuItemFixture exitMenuItem;

        @SwingComponent(name = "None")
        private JMenuItemFixture noneMode;

        @SwingComponent(name = "Breadth-First Search")
        private JMenuItemFixture breadthFirstSearch;

        @SwingComponent(name = "Depth-First Search")
        private JMenuItemFixture depthFirstSearch;

        @SwingComponent(name = "Display")
        private JLabelFixture display;

        public GraphTraversalAlgorithmTests() {
            super(new MainFrame());
        }

        @DynamicTest(order = 1, feedback = "Initially graph panel should not contain anything.")
        CheckResult isEmptyGraph() {
            assertThat(count(ComponentType.ANY))
                    .isEqualTo(0);

            return correct();
        }

        @DynamicTest(order = 2, feedback = "Initial Mode must be \"Add a Vertex\"")
        CheckResult isCorrectCurrentMode() {
            modeText.requireText(Pattern.compile(".*add a vertex.*", Pattern.CASE_INSENSITIVE));
            return correct();
        }

        void changeModeToAddAVertex() {
            addAVertexMode.click();
        }

        void insertVertex(Vertex vertex) {

            getWindow().robot().click(graph.target(), vertex.point());

            JOptionPaneFixture jOptionPaneFixture;
            try {

                jOptionPaneFixture = JOptionPaneFinder
                        .findOptionPane()
                        .withTimeout(200)
                        .using(getWindow().robot());

            } catch (WaitTimedOutError e) {
                throw new WrongAnswer("Timeout waiting for a dialog box to open");
            }

            try {

                jOptionPaneFixture.textBox();

            } catch (ComponentLookupException e) {
                throw new WrongAnswer("A text box was not found inside the dialog box");
            }

            try {

                jOptionPaneFixture.okButton();

            } catch (ComponentLookupException e) {
                throw new WrongAnswer("A ok button was not found inside the dialog box");
            }

            try {

                jOptionPaneFixture.cancelButton();

            } catch (ComponentLookupException e) {
                throw new WrongAnswer("A cancel button was not found inside the dialog box");
            }

            try {

                jOptionPaneFixture.requireTitle(Pattern.compile("vertex", Pattern.CASE_INSENSITIVE));

            } catch (Exception ignore) {
                throw new WrongAnswer("Dialog box title should contain \"Vertex\"");
            }


            try {

                jOptionPaneFixture
                        .textBox()
                        .setText(vertex.id());

                jOptionPaneFixture
                        .textBox()
                        .requireText(vertex.id());
            } catch (Exception e) {
                throw new WrongAnswer("Cannot write text '" + vertex.id() + "' in dialog box / Incorrect text after writing. Expected: '" + vertex.id() + "'");
            }

            JOptionPaneFinder
                    .findOptionPane()
                    .using(getWindow().robot())
                    .okButton()
                    .click();

            try {

                JOptionPaneFinder
                        .findOptionPane()
                        .withTimeout(200)
                        .using(getWindow().robot());

                throw new WrongAnswer("Dialog box did not disappear after clicking ok");
            } catch (WaitTimedOutError ignored) {
            }

            Optional<Component> vOp = getVertex(vertex.id());

            if (vOp.isEmpty()) {
                throw new WrongAnswer(vertex.name() + " was not created. It is not present in graph panel");
            }

            if (!(vOp.get() instanceof JPanel)) {
                throw new WrongAnswer("Each Vertex should be represented by a JPanel.");
            }

            JPanel v = (JPanel) vOp.get();

            if (v.getSize().getHeight() != 50 || v.getSize().getWidth() != 50) {
                Dimension expected = new Dimension(50, 50);
                Dimension got = v.getSize();
                throw new WrongAnswer("Incorrect Vertex Size. Expected: " + expected + ", Got: " + got);
            }

            Optional<Component> vl = getVertexLabel(vertex.id());

            if (vl.isEmpty()) {
                throw new WrongAnswer("Label of " + vertex.name() + " is not Present.");
            }

            if (!(vl.get() instanceof JLabel)) {
                throw new WrongAnswer("Each Vertex label must be represented by JLabel.");
            }

            JLabel vLabel = (JLabel) vl.get();

            if (!Objects.equals(vLabel.getParent().getName(), vertex.name())) {
                throw new WrongAnswer("Each Label of each vertex must be present inside it.");
            }

            if (!Objects.equals(vLabel.getText(), vertex.id())) {
                throw new WrongAnswer("Vertex Label Should Contain ID of Vertex");
            }

            Point got = v.getLocation();
            Point expected = new Point((int) (vertex.point().getX() - 25), (int) (vertex.point().getY() - 25));
            if (!expected.equals(got)) {
                throw new WrongAnswer("Incorrect Position. Expected: " + expected + ", Got: " + got);
            }

        }

        void changeModeToAddAnEdge() {
            addAnEdgeMode.click();
        }

        void insertEdge(Edge edge) {


            getWindow().robot().click(getVertex(edge.from()).orElseThrow());
            getWindow().robot().click(getVertex(edge.to()).orElseThrow());

            JOptionPaneFixture jOptionPaneFixture;

            try {
                jOptionPaneFixture = JOptionPaneFinder
                        .findOptionPane()
                        .withTimeout(1000)
                        .using(getWindow().robot());
            } catch (WaitTimedOutError e) {
                throw new WrongAnswer("Clicking on two vertices in the \"Add an Edge\" mode; a new window must pop up prompting for edge weight");
            }

            try {
                jOptionPaneFixture.okButton();
            } catch (ComponentLookupException e) {
                throw new WrongAnswer("A ok button was not found in edge weight prompting input box.");
            }

            try {
                jOptionPaneFixture.cancelButton();
            } catch (ComponentLookupException e) {
                throw new WrongAnswer("A cancel button was not found in edge weight prompting input box.");
            }

            try {
                jOptionPaneFixture.textBox();
            } catch (ComponentLookupException e) {
                throw new WrongAnswer("A text box was not found in edge weight prompting input box.");
            }

            try {
                jOptionPaneFixture
                        .textBox()
                        .setText(edge.weight() + "");

                jOptionPaneFixture
                        .textBox()
                        .requireText(edge.weight() + "");
            } catch (Exception e) {
                throw new WrongAnswer("Could not enter text in the edge weight prompting dialog box.");
            }

            jOptionPaneFixture
                    .okButton()
                    .click();

            try {
                JOptionPaneFinder
                        .findOptionPane()
                        .withTimeout(1000)
                        .using(getWindow().robot());

                throw new WrongAnswer("Dialog box must close after clicking on ok button.");
            } catch (WaitTimedOutError ignored) {
            }

            Component aTob = getEdge(edge.from(), edge.to()).orElseThrow(() -> new WrongAnswer("\"" + edge.labelName() + "\" was not found!"));

            Component bToa = getEdge(edge.to(), edge.from()).orElseThrow(() -> new WrongAnswer("\"" + edge.opposite().labelName() + "\" was not found!"));

            Component label = getEdgeLabel(edge.from(), edge.to()).orElseThrow(() -> new WrongAnswer("Edge Label which should contain the edge weight was not found in graph."));

            if (!(aTob instanceof JComponent) || !(bToa instanceof JComponent))
                throw new WrongAnswer("Edge must be represented by JComponent");

            if (!(label instanceof JLabel))
                throw new WrongAnswer("EdgeLabel must be represented by JLabel");

            if (!Objects.equals(graph.target(), label.getParent()))
                throw new WrongAnswer("Parent of each edge label is the graph itself not the edge.");


            try {
                assertThat(((JLabel) label).getText())
                        .containsIgnoringCase(edge.weight() + "");
            } catch (Exception e) {
                throw new WrongAnswer("Edge Label should hold the weight of the respective edge");
            }


        }

        void checkVertexCount(Vertex[] vertices) {
            int got = count(ComponentType.VERTEX);
            int expected = vertices.length;
            if (expected != got)
                throw new WrongAnswer("Incorrect Vertex Count. Expected = " + expected + ", Got = " + got);

        }

        void checkEdgeCount(Edge[] edges) {
            int got = count(ComponentType.EDGE);
            int expected = edges.length * 2;
            if (expected != got)
                throw new WrongAnswer("Incorrect Edge Count. Expected = " + expected + ", Got = " + got);

        }

        void checkVertexLabelCount(Vertex[] vertices) {
            int got = count(ComponentType.VERTEX_LABEL);
            int expected = vertices.length;
            if (expected != got)
                throw new WrongAnswer("Incorrect Vertex Label (id) Count. Expected = " + expected + ", Got = " + got);
        }

        void checkEdgeLabelCount(Edge[] edges) {
            int got = count(ComponentType.EDGE_LABEL);
            int expected = edges.length;
            if (expected != got)
                throw new WrongAnswer("Incorrect Edge Label Count. Expected = " + expected + ", Got = " + got);
        }

        GraphData[] graphs = new GraphData[]{new GraphDataOne(), new GraphDataTwo()};

        @DynamicTest(order = 3, data = "graphs", feedback = "Error while running / trying to run graph traversal algorithms")
        CheckResult checkGraphTraversal(GraphData data) {

            Vertex[] vertices = data.getVertices().toArray(new Vertex[0]);
            Edge[] edges = data.getEdges().toArray(new Edge[0]);

            this.changeModeToAddAVertex();

            for (Vertex v : vertices) {
                insertVertex(v);
            }

            this.changeModeToAddAnEdge();

            for (Edge e : edges) {
                insertEdge(e);
            }

            checkVertexCount(vertices);
            checkEdgeCount(edges);
            checkVertexLabelCount(vertices);
            checkEdgeLabelCount(edges);

            runAlgorithm(data, depthFirstSearch, data.getDFSText());
            runAlgorithm(data, breadthFirstSearch, data.getBFSText());

            newMenuItem.click();

            return correct();
        }

        private void runAlgorithm(GraphData data, JMenuItemFixture algo, String answer) {
            algo.click();

            if (!display.text().contains("Please choose a starting vertex"))
                throw new WrongAnswer("Display label should show \"Please choose a starting vertex\" if an algorithm is selected for execution.");

            getWindow().robot().click(getVertex(data.getSource()).orElseThrow(() -> new WrongAnswer("Vertex disappeared after creation.")));

            if (!modeText.text().matches(".*None.*"))
                throw new WrongAnswer("Mode after selecting an algorithm should be \"None\".");

            if (!display.text().contains("Please wait..."))
                throw new WrongAnswer("Display label should show \"Please wait...\" after selecting source / while the algorithm is executing.");

            int totalTime = 0;
            while (display.text().contains("Please wait...")) {
              if (totalTime > 60000) {
                throw new WrongAnswer("Algorithm Running for more than 1 min");
              }
              Utils.sleep(100);
              totalTime += 100;
            }

            if (!display.text().contains(answer))
                throw new WrongAnswer("Wrong Answer in " + algo.target().getName() + "." + " Expected: " + answer + ", Got: " + display.text());
        }

        private int count(ComponentType type) {
            return (int) getAllComponents(graph.target())
                    .stream()
                    .filter(it -> it.getName() != null && it.getName().startsWith(type.prefix()))
                    .count();
        }

        private Optional<Component> getVertexLabel(String id) {
            String name = Vertex.of(id).labelName();

            return getAllComponents(graph.target())
                    .stream()
                    .filter(it -> Objects.equals(it.getName(), name))
                    .findFirst();

        }

        private Optional<Component> getEdgeLabel(String from, String to) {
            String name = Edge.of(from, to).labelName();

            return getAllComponents(graph.target())
                    .stream()
                    .filter(it -> Objects.equals(it.getName(), name))
                    .findFirst();

        }

        private Optional<Component> getEdge(String from, String to) {
            String name = Edge.of(from, to).name();

            return getAllComponents(graph.target())
                    .stream()
                    .filter(it -> Objects.equals(it.getName(), name))
                    .findFirst();
        }

        private Optional<Component> getVertex(String id) {
            String name = Vertex.of(id).name();

            return getAllComponents(graph.target())
                    .stream()
                    .filter(it -> Objects.equals(name, it.getName()))
                    .findFirst();
        }
    }
  learner_created: false
- name: test/GraphData.java
  visible: false
  text: |
    import java.util.List;

    public interface GraphData {
        List<Vertex> getVertices();

        List<Edge> getEdges();

        String getDFSText();

        String getBFSText();

        String getSource();
    }
  learner_created: false
- name: test/GraphDataOne.java
  visible: false
  text: |
    import java.awt.*;
    import java.util.List;

    public class GraphDataOne implements GraphData {

        @Override
        public List<Vertex> getVertices() {
            return List.of(
                    new Vertex("A", new Point(175, 359)),
                    new Vertex("B", new Point(224, 176)),
                    new Vertex("C", new Point(365, 363)),
                    new Vertex("D", new Point(408, 67)),
                    new Vertex("E", new Point(531, 235)),
                    new Vertex("F", new Point(590, 64))
            );
        }

        @Override
        public List<Edge> getEdges() {
            return List.of(
                    new Edge("A", "B", 1),
                    new Edge("B", "D", 2),
                    new Edge("D", "F", 3),
                    new Edge("F", "E", 4),
                    new Edge("E", "C", 5),
                    new Edge("C", "A", 6),
                    new Edge("B", "E", 7),
                    new Edge("D", "C", 8),
                    new Edge("B", "C", 9),
                    new Edge("D", "E", 10)
            );
        }

        @Override
        public String getDFSText() {
            return "DFS : A -> B -> D -> F -> E -> C";
        }

        @Override
        public String getBFSText() {
            return "BFS : A -> B -> C -> D -> E -> F";
        }

        @Override
        public String getSource() {
            return "A";
        }
    }
  learner_created: false
- name: test/GraphDataTwo.java
  visible: false
  text: |
    import java.awt.*;
    import java.util.List;

    public class GraphDataTwo implements GraphData {

        @Override
        public List<Vertex> getVertices() {
            return List.of(
                    new Vertex("1", new Point(361, 54)),
                    new Vertex("2", new Point(152, 164)),
                    new Vertex("3", new Point(599, 155)),
                    new Vertex("4", new Point(47, 394)),
                    new Vertex("5", new Point(291, 392)),
                    new Vertex("6", new Point(419, 390)),
                    new Vertex("7", new Point(744, 392))
            );
        }

        @Override
        public List<Edge> getEdges() {
            return List.of(
                    new Edge("1", "2", 1),
                    new Edge("1", "3", 3),
                    new Edge("2", "4", 5),
                    new Edge("5", "2", 7),
                    new Edge("6", "3", 9),
                    new Edge("7", "3", 11)
            );
        }

        @Override
        public String getDFSText() {
            return "DFS : 1 -> 2 -> 4 -> 5 -> 3 -> 6 -> 7";
        }

        @Override
        public String getBFSText() {
            return "BFS : 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7";
        }

        @Override
        public String getSource() {
            return "1";
        }
    }
  learner_created: false
- name: src/visualizer/Algorithm.java
  visible: true
  learner_created: true
- name: src/visualizer/DepthFirstSearch.java
  visible: true
  learner_created: true
- name: src/visualizer/BreadthFirstSearch.java
  visible: true
  learner_created: true
feedback_link: https://hyperskill.org/learn/step/15628#comment
status: Solved
feedback:
  message: Congratulations!
  time: Thu, 02 Jun 2022 04:29:53 UTC
record: 5
